<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EZ GUI: SpriteBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="contents">
<h1>SpriteBase Class Reference</h1><!-- doxytag: class="SpriteBase" --><!-- doxytag: inherits="SpriteRoot" --><div class="dynheader">
Inheritance diagram for SpriteBase:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_sprite_base.gif" usemap="#SpriteBase_map" alt=""/>
  <map id="SpriteBase_map" name="SpriteBase_map">
<area href="class_sprite_root.html" alt="SpriteRoot" shape="rect" coords="0,0,99,24"/>
<area href="class_auto_sprite_base.html" alt="AutoSpriteBase" shape="rect" coords="0,112,99,136"/>
</map>
 </div>
</div>

<p><a href="class_sprite_base-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">HORIZONTAL_ALIGN</a> { <a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">NONE</a>, 
<a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">LEFT</a>, 
<a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">RIGHT</a>, 
<a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">CENTER</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Specifies what the object will be aligned relative to on the horizontal axis. </p>
 <a href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">VERTICAL_ALIGN</a> { <a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">NONE</a>, 
<a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">TOP</a>, 
<a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">BOTTOM</a>, 
<a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">CENTER</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Specifies what the object will be aligned relative to on the vertical axis. </p>
 <a href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#ae05f863c7be4bdd30515bb335472deb9">AnimCompleteDelegate</a> (<a class="el" href="class_sprite_base.html">SpriteBase</a> sprite)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#ab0458aed4b016766469c1670e5503950">AnimFrameDelegate</a> (<a class="el" href="class_sprite_base.html">SpriteBase</a> sprite, int frame)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a1645f45e87839994a623d8a70135b000">Clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets important sprite values to defaults for reuse.  <a href="#a1645f45e87839994a623d8a70135b000"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a1f5ee0eb97ebc94d31fc1e31fcb12e68">Delete</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If non-managed, call <a class="el" href="class_sprite_base.html#a1f5ee0eb97ebc94d31fc1e31fcb12e68" title="If non-managed, call Delete() before destroying this component or the GameObject...">Delete()</a> before destroying this component or the GameObject to which it is attached. Memory leaks can ensue otherwise.  <a href="#a1f5ee0eb97ebc94d31fc1e31fcb12e68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#aa1bf525b3837b3456d23d9a03dda766d">Hide</a> (bool tf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hides or displays the sprite by disabling/enabling the sprite's mesh renderer component, or if managed, sets the mesh size to 0.  <a href="#aa1bf525b3837b3456d23d9a03dda766d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a923fa607ba560c946de87c05e6da85c5">SetAnimCompleteDelegate</a> (AnimCompleteDelegate del)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the delegate to be called upon animation completion.  <a href="#a923fa607ba560c946de87c05e6da85c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#ad31805dac2d46592bc30a95eabf899cb">SetAnimFrameDelegate</a> (AnimFrameDelegate del)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the delegate to be called each frame of animation.  <a href="#ad31805dac2d46592bc30a95eabf899cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a8849952300de0c69e246cea541d30e3a">SetSpriteResizedDelegate</a> (SpriteResizedDelegate del)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the delegate to be called when the sprite is resized.  <a href="#a8849952300de0c69e246cea541d30e3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#acd1248c74ff3e79c75ba994512d6e117">AddSpriteResizedDelegate</a> (SpriteResizedDelegate del)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the delegate to be called when the sprite is resized.  <a href="#acd1248c74ff3e79c75ba994512d6e117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a10f2bcae2161110b2acd5e5b9cca3300">RemoveSpriteresizedDelegate</a> (SpriteResizedDelegate del)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the specified delegate from the list of those to be called when the sprite is resized.  <a href="#a10f2bcae2161110b2acd5e5b9cca3300"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a2ac2df7765bc1baeb3643948024b30a1">SetFramerate</a> (float fps)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the framerate at which the current animation plays. NOTE: This only has effect if called AFTER PlayAnim() is called. Otherwise, PlayAnim() sets the framerate to whatever is specified in the animation itself.  <a href="#a2ac2df7765bc1baeb3643948024b30a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a88bdbcaa86cdd2e54908dae42dd79872">PauseAnim</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pauses the currently-playing animation.  <a href="#a88bdbcaa86cdd2e54908dae42dd79872"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#aa3d61d10c3119a19ed83376e2269d121">StopAnim</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops the current animation from playing and resets it to the beginning for playing again. The sprite then reverts to the static image.  <a href="#aa3d61d10c3119a19ed83376e2269d121"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a8b88afbf9c807629620803fc9e0fb982">RevertToStatic</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverts the sprite to its static (non-animating) default appearance.  <a href="#a8b88afbf9c807629620803fc9e0fb982"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#ac98a457ace0eee0fecf82c8e089cc1a5">IsAnimating</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the sprite is currently animating.  <a href="#ac98a457ace0eee0fecf82c8e089cc1a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a225681fbdb6d79c769c107293949f37f">SpriteResizedDelegate</a> (float newWidth, float newHeight, <a class="el" href="class_sprite_root.html">SpriteRoot</a> sprite)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#affa83a7ae3fce4f0137273a59e29ccc6">Copy</a> (<a class="el" href="class_sprite_root.html">SpriteRoot</a> s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies all the vital attributes of another sprite.  <a href="#affa83a7ae3fce4f0137273a59e29ccc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a09d7f0014281fa0dcdd872c8ad4826a9">PositionOnScreen</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Repositions the object using the existing screen-space settings.  <a href="#a09d7f0014281fa0dcdd872c8ad4826a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a481a3e5c7d1b3370935564ca611fa9fe">PositionOnScreen</a> (int x, int y, float depth)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Positions the object using screen coordinates, according to the relativity settings stored in relativeToScreen.  <a href="#a481a3e5c7d1b3370935564ca611fa9fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#aabf07745fff23716a19e591a4d00ecb0">PositionOnScreen</a> (Vector3 pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Positions the object using screen coordinates, according to the relativity settings stored in relativeToScreen.  <a href="#aabf07745fff23716a19e591a4d00ecb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a3c11e0d03884e3af7b5040737f2064bd">CalcSize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recalculates the width and height of the sprite based upon the change in its UV dimensions (autoResize) or on the current camera's disposition (pixelPerfect).  <a href="#a3c11e0d03884e3af7b5040737f2064bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#adf9809122c570941ff132a9904dcc93c">SetSize</a> (float <a class="el" href="class_sprite_root.html#afeafcd5c4d1b332e1ff9260eee857145">width</a>, float <a class="el" href="class_sprite_root.html#a6bf98fa584df909a7864c4bccfda0b75">height</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the physical dimensions of the sprite in the plane selected.  <a href="#adf9809122c570941ff132a9904dcc93c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a6b14b0241981a1c7c73e94a293aca4b3">TruncateRight</a> (float pct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncates the right edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation.  <a href="#a6b14b0241981a1c7c73e94a293aca4b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a062df66fcfa288caa1d42cbc949c5224">TruncateLeft</a> (float pct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncates the left edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation.  <a href="#a062df66fcfa288caa1d42cbc949c5224"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#acfad33ecdc14bbb036624684d725ce28">TruncateTop</a> (float pct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncates the top edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation.  <a href="#acfad33ecdc14bbb036624684d725ce28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#afabfd5b77d9f2801054d09f70363f955">TruncateBottom</a> (float pct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncates the bottom edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation.  <a href="#afabfd5b77d9f2801054d09f70363f955"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a8477b9dd7e2ac97b2f683ef7f50d1295">Untruncate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes any truncation.  <a href="#a8477b9dd7e2ac97b2f683ef7f50d1295"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a97d10b8e450bb429bab82eaeda1bdf12">Unclip</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes any clipping that is being applied to the sprite.  <a href="#a97d10b8e450bb429bab82eaeda1bdf12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#aff78916688134aa447c8071fe552b209">UpdateUVs</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies any changes to the UVs to the actual sprite mesh.  <a href="#aff78916688134aa447c8071fe552b209"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a07898604b8c12c66429d26e8d6fbc3a9">SetColor</a> (Color c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's color to the specified color.  <a href="#a07898604b8c12c66429d26e8d6fbc3a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a4f2fdef32da501a717c69eef466d2135">SetCamera</a> (Camera c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the camera to use when calculating a pixel-perfect sprite size.  <a href="#a4f2fdef32da501a717c69eef466d2135"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#abc1b7cd60a2b90903fe4ea925f9c17d1">IsHidden</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the sprite is currently set to be hideAtStart (whether its mesh renderer component is enabled).  <a href="#abc1b7cd60a2b90903fe4ea925f9c17d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a26d2276f1705f7e61019cf621dd6d2b1">SetBleedCompensation</a> (float x, float y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>).  <a href="#a26d2276f1705f7e61019cf621dd6d2b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ab9108d36331abd7a6b629b3af7193a85">SetBleedCompensation</a> (Vector2 xy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>).  <a href="#ab9108d36331abd7a6b629b3af7193a85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#adce43163ad8ad0693c3ea7c109d8408b">SetPlane</a> (<a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a> p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the plane in which the sprite is to be drawn. See: <a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>.  <a href="#adce43163ad8ad0693c3ea7c109d8408b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a4c7f3a0e628f66c612bc80ff4a003021">SetWindingOrder</a> (<a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a> order)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the winding order to use. See <a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>.  <a href="#a4c7f3a0e628f66c612bc80ff4a003021"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a0352fc2f67d2258329f74dcc86bd4d56">SetDrawLayer</a> (int layer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the draw layer of the sprite (only applies to managed sprites).  <a href="#a0352fc2f67d2258329f74dcc86bd4d56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a355b24c10aa7ae976c21e944f3eb22f9">SetFrameInfo</a> (<a class="el" href="struct_s_p_r_i_t_e___f_r_a_m_e.html">SPRITE_FRAME</a> fInfo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's frame info, which includes UVs, offsets, etc.  <a href="#a355b24c10aa7ae976c21e944f3eb22f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ab7b38c49c508eb9300fa9116a3074ace">SetUVs</a> (Rect uv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's UVs to the specified values.  <a href="#ab7b38c49c508eb9300fa9116a3074ace"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a2099af0859ccd329e09ff83177811127">SetUVsFromPixelCoords</a> (Rect pxCoords)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's UVs from pixel coordinates.  <a href="#a2099af0859ccd329e09ff83177811127"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Rect&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a8c337e11b78774a1cc4e2a47d3343c95">GetUVs</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current UV coordinates of the sprite (before bleed compensation).  <a href="#a8c337e11b78774a1cc4e2a47d3343c95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a778d47660b7a9a6695aa77ae24862434">GetVertices</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to the sprite's vertices. NOTE: You can only directly modify the sprite's vertices if it is a non-managed sprite.  <a href="#a778d47660b7a9a6695aa77ae24862434"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a729b35193db1829b0732151d4de39d05">GetCenterPoint</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the center point of the sprite, taking into account the actual positions of vertices.  <a href="#a729b35193db1829b0732151d4de39d05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#af114f93fa3ad60b469e07346911a5cad">SetAnchor</a> (<a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a> a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the anchor method to use. See <a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>.  <a href="#af114f93fa3ad60b469e07346911a5cad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a6ae2f4d7bce23b55d8b9d273434623e7">SetOffset</a> (Vector3 o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the offset of the sprite from its GameObject. See <a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457" title="Offsets the sprite, in world space, from the center of its GameObject.">offset</a>.  <a href="#a6ae2f4d7bce23b55d8b9d273434623e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e">PixelSpaceToUVSpace</a> (Vector2 xy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()!  <a href="#aa9db529bff27dfcdbb0e5e33ed0fbc2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a61151a87fd06071bd680ebad9946512e">PixelSpaceToUVSpace</a> (int x, int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()!  <a href="#a61151a87fd06071bd680ebad9946512e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975">PixelCoordToUVCoord</a> (Vector2 xy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()!  <a href="#ae3931a73d6842ec8a98d93b718004975"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a5ff8725f90b8609efe0f4fff819bac74">PixelCoordToUVCoord</a> (int x, int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()!  <a href="#a5ff8725f90b8609efe0f4fff819bac74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">abstract int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#afdcc033b3c5c6abcb63c2f3b6dba4596">GetStateIndex</a> (string stateName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the state with the specified name. -1 if no state matching the specified name is found.  <a href="#afdcc033b3c5c6abcb63c2f3b6dba4596"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">abstract void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a4df752403ae612fea2d492cfaf131e0b">SetState</a> (int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite to the specified state/animation.  <a href="#a4df752403ae612fea2d492cfaf131e0b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a9c2a037051bc8954928bc97f78c8748b">playAnimOnStart</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When set to true, the sprite will play the default animation (see <a class="el" href="class_sprite_base.html#a9d3a230326feff1dc46a065f50d4d5e8" title="Index of the animation to play by default.">defaultAnim</a>) when the sprite is instantiated.  <a href="#a9c2a037051bc8954928bc97f78c8748b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a9d3a230326feff1dc46a065f50d4d5e8">defaultAnim</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index of the animation to play by default.  <a href="#a9d3a230326feff1dc46a065f50d4d5e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a27b40cf9515a2d0cae6391fc974c8316">managed</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When true, the sprite will be managed by the selected sprite manager script. When false, the sprite has its own mesh and will be batched automatically with other sprites (when available - Unity iPhone).  <a href="#a27b40cf9515a2d0cae6391fc974c8316"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_manager.html">SpriteManager</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a2ce487455dd3b14e10cfa97a37b3da20">manager</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference to the manager which will manage this sprite, provided managed is set to true.  <a href="#a2ce487455dd3b14e10cfa97a37b3da20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a38effd07c9700447283d092a0981e411">drawLayer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The layer in which the sprite will be drawn if managed.  <a href="#a38effd07c9700447283d092a0981e411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a5be17e1b254ce8a2c0b2f16a0be9a3a3">persistent</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This must be set to true at design time for the sprite to survive loading a new level.  <a href="#a5be17e1b254ce8a2c0b2f16a0be9a3a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a821509586d7b454250d1c7c0b3dd4f74">plane</a> = SPRITE_PLANE.XY</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The plane in which the sprite will be drawn.  <a href="#a821509586d7b454250d1c7c0b3dd4f74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a2053a628b672c6b3140ebc2e92264b09">winding</a> = WINDING_ORDER.CW</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The winding order of the sprite's polygons - determines the direction the sprite will "face".  <a href="#a2053a628b672c6b3140ebc2e92264b09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#afeafcd5c4d1b332e1ff9260eee857145">width</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Width of the sprite in world space.  <a href="#afeafcd5c4d1b332e1ff9260eee857145"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a6bf98fa584df909a7864c4bccfda0b75">height</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Height of the sprite in world space.  <a href="#a6bf98fa584df909a7864c4bccfda0b75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f">bleedCompensation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Will contract the UV edges of the sprite by the specified amount to prevent "bleeding" from neighboring pixels, especially when mipmapping.  <a href="#a8a9de6bf34778b74f87b3d8e71c3342f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a3ea8ab87a750bfafc3cffc34b14f3eba">anchor</a> = ANCHOR_METHOD.TEXTURE_OFFSET</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Anchor method to use. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a></dd></dl>
<p>.  <a href="#a3ea8ab87a750bfafc3cffc34b14f3eba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ae3ebdc6d208c66fcc58fe9bdd1e993fe">pixelPerfect</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatically sizes the sprite so that it will display pixel-perfect on-screen. NOTE: If you change the orthographic size of the camera or the distance between the sprite and a perspective camera, call <a class="el" href="class_sprite_root.html#a4f2fdef32da501a717c69eef466d2135" title="Sets the camera to use when calculating a pixel-perfect sprite size.">SetCamera()</a> to make the text pixel-perfect again. However, if you want automatic resizing functionality without being pixel-perfect and therefore allowing zooming in and out, use <a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd" title="Automatically resizes the sprite based on its new UV dimensions compared to its previous...">autoResize</a> instead.  <a href="#ae3ebdc6d208c66fcc58fe9bdd1e993fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd">autoResize</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatically resizes the sprite based on its new UV dimensions compared to its previous dimensions. Setting this to true allows you to use non-uniform sized sprites for animation without causing the sprite to appear "squashed" while animating.  <a href="#ad6bda2f46906d69166ee4b931c3108dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457">offset</a> = new Vector3()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Offsets the sprite, in world space, from the center of its GameObject.  <a href="#a437424afa712a3ae537768cc0e3a2457"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Color&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a206a1db950fc52aaef5b535a7b1a938a">color</a> = Color.white</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The color to be used by all four of the sprite's vertices. This can be used to color, highlight, or fade the sprite. Be sure to use a vertex-colored shader for this to have an effect.  <a href="#a206a1db950fc52aaef5b535a7b1a938a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a9905374808829c2c6a15ffeb0170bf52">hideAtStart</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the sprite will be hideAtStart when it starts.  <a href="#a9905374808829c2c6a15ffeb0170bf52"></a><br/></td></tr>
<tr><td colspan="2"><h2>Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#ae427641cebb3e76e7a2cb2ffdf445836">Animating</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Property useful for use with EZ Game Saver. When it gets set, the current animation is started. Include this, along with CurAnimIndex, as a saved property so that any playing animation is resumed.  <a href="#ae427641cebb3e76e7a2cb2ffdf445836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a88bfefa27afedef3c2ab1883fdb2a364">CurAnimIndex</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Property useful for use with EZ Game Saver. Include this as a saved property, along with Animating, so that any playing animation is resumed.  <a href="#a88bfefa27afedef3c2ab1883fdb2a364"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ac5a83817fe0a7ccf7910331b2e4eb6aa">Managed</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite to a managed or batched state.  <a href="#ac5a83817fe0a7ccf7910331b2e4eb6aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_rect3_d.html">Rect3D</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a214c7409b2047bd2d533872271a4dc46">ClippingRect</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rect against which the sprite should be clipped. The sprite will be immediately clipped by this rect when set. When setting, the rect should be in world space.  <a href="#a214c7409b2047bd2d533872271a4dc46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a222c8253fa3ef1911732d0de73cefb49">Clipped</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for whether the sprite is to be clipped by any already-specified clipping rect.  <a href="#a222c8253fa3ef1911732d0de73cefb49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a50292aa01cd979d345893d6a81c6f39b">UnclippedTopLeft</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The top-left corner of the sprite when no clipping or trimming is applied.  <a href="#a50292aa01cd979d345893d6a81c6f39b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#af4326379f44bf2e7f8410fb71add0476">UnclippedBottomRight</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bottom-right corner of the sprite when no clipping or trimming is applied.  <a href="#af4326379f44bf2e7f8410fb71add0476"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a120de0df612b60e3722b3ef8a759faa5">TopLeft</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the position of the top-left vertex of the sprite after any clipping or trimming.  <a href="#a120de0df612b60e3722b3ef8a759faa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ab801616440fd6b9500f05dd3565d16b8">BottomRight</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the position of the bottom-right vertex of the sprite after any clipping or trimming.  <a href="#ab801616440fd6b9500f05dd3565d16b8"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Serves as the base for defining an animatable sprite. This class should not actually be used despite the fact that Unity will allow you to attach it to a GameObject. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a79b7138073d866284a170e4d8b3a9217"></a><!-- doxytag: member="SpriteBase::ANCHOR_METHOD" ref="a79b7138073d866284a170e4d8b3a9217" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">SpriteRoot::ANCHOR_METHOD</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The anchoring scheme of a sprite. The anchor point is the point on the sprite that will remain stationary when the sprite's size changes. For a health bar that "grows" to the right while its left edge remains stationary, you would use UPPER_LEFT, MIDDLE_LEFT, or BOTTOM_LEFT.</p>
<p>For a health bar that "grows" upward while the bottom edge remains stationary, you would use BOTTOM_LEFT, BOTTOM_CENTER, or BOTTOM_RIGHT.</p>

</div>
</div>
<a class="anchor" id="ad31e772b9c659d24c829386c63f50566"></a><!-- doxytag: member="SpriteBase::HORIZONTAL_ALIGN" ref="ad31e772b9c659d24c829386c63f50566" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">SpriteRoot::HORIZONTAL_ALIGN</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies what the object will be aligned relative to on the horizontal axis. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad31e772b9c659d24c829386c63f50566"></a><!-- doxytag: member="NONE" ref="ad31e772b9c659d24c829386c63f50566" args="" -->NONE</em>&nbsp;</td><td>
<p>The object will not be repositioned along the X axis. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad31e772b9c659d24c829386c63f50566"></a><!-- doxytag: member="LEFT" ref="ad31e772b9c659d24c829386c63f50566" args="" -->LEFT</em>&nbsp;</td><td>
<p>The X coordinate of screenPos will be interpreted as the number of pixels from the left edge of the screen. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad31e772b9c659d24c829386c63f50566"></a><!-- doxytag: member="RIGHT" ref="ad31e772b9c659d24c829386c63f50566" args="" -->RIGHT</em>&nbsp;</td><td>
<p>The X coordinate of screenPos will be interpreted as the number of pixels from the right edge of the screen. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad31e772b9c659d24c829386c63f50566"></a><!-- doxytag: member="CENTER" ref="ad31e772b9c659d24c829386c63f50566" args="" -->CENTER</em>&nbsp;</td><td>
<p>The X coordinate of screenPos will be interpreted as the number of pixels from the center of the screen. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f354b80a58bab8f31f7966750800e57"></a><!-- doxytag: member="SpriteBase::SPRITE_PLANE" ref="a4f354b80a58bab8f31f7966750800e57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SpriteRoot::SPRITE_PLANE</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The plane in which a sprite should be drawn. </p>

</div>
</div>
<a class="anchor" id="af7a4d8ff195106468232a3e5a7d32c78"></a><!-- doxytag: member="SpriteBase::VERTICAL_ALIGN" ref="af7a4d8ff195106468232a3e5a7d32c78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">SpriteRoot::VERTICAL_ALIGN</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies what the object will be aligned relative to on the vertical axis. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af7a4d8ff195106468232a3e5a7d32c78"></a><!-- doxytag: member="NONE" ref="af7a4d8ff195106468232a3e5a7d32c78" args="" -->NONE</em>&nbsp;</td><td>
<p>The object will not be repositioned along the Y axis. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af7a4d8ff195106468232a3e5a7d32c78"></a><!-- doxytag: member="TOP" ref="af7a4d8ff195106468232a3e5a7d32c78" args="" -->TOP</em>&nbsp;</td><td>
<p>The Y coordinate of screenPos will be interpreted as the number of pixels from the top edge of the screen. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af7a4d8ff195106468232a3e5a7d32c78"></a><!-- doxytag: member="BOTTOM" ref="af7a4d8ff195106468232a3e5a7d32c78" args="" -->BOTTOM</em>&nbsp;</td><td>
<p>The Y coordinate of screenPos will be interpreted as the number of pixels from the bottom edge of the screen. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af7a4d8ff195106468232a3e5a7d32c78"></a><!-- doxytag: member="CENTER" ref="af7a4d8ff195106468232a3e5a7d32c78" args="" -->CENTER</em>&nbsp;</td><td>
<p>The Y coordinate of screenPos will be interpreted as the number of pixels from the center of the screen. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6a06ad89a880accb25794e862733074"></a><!-- doxytag: member="SpriteBase::WINDING_ORDER" ref="aa6a06ad89a880accb25794e862733074" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">SpriteRoot::WINDING_ORDER</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines which way the polygons of a sprite should be wound. The two options are clock-wise (CW) and counter clock-wise (CCW). These determine the direction the sprite will "face". </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acd1248c74ff3e79c75ba994512d6e117"></a><!-- doxytag: member="SpriteBase::AddSpriteResizedDelegate" ref="acd1248c74ff3e79c75ba994512d6e117" args="(SpriteResizedDelegate del)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.AddSpriteResizedDelegate </td>
          <td>(</td>
          <td class="paramtype">SpriteResizedDelegate&nbsp;</td>
          <td class="paramname"> <em>del</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the delegate to be called when the sprite is resized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>del</em>&nbsp;</td><td>A delegate to be called when the sprite is resized.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae05f863c7be4bdd30515bb335472deb9"></a><!-- doxytag: member="SpriteBase::AnimCompleteDelegate" ref="ae05f863c7be4bdd30515bb335472deb9" args="(SpriteBase sprite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate void SpriteBase.AnimCompleteDelegate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_base.html">SpriteBase</a>&nbsp;</td>
          <td class="paramname"> <em>sprite</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines a delegate that can be called upon animation completion. Use this if you want something to happen as soon as an animation reaches the end. Receives a reference to the sprite.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite</em>&nbsp;</td><td>A reference to the sprite whose animation has finished.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0458aed4b016766469c1670e5503950"></a><!-- doxytag: member="SpriteBase::AnimFrameDelegate" ref="ab0458aed4b016766469c1670e5503950" args="(SpriteBase sprite, int frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate void SpriteBase.AnimFrameDelegate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_base.html">SpriteBase</a>&nbsp;</td>
          <td class="paramname"> <em>sprite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines a delegate that can be called once for each frame of animation. Use this if you want something to happen on an animation frame. Receives a reference to the sprite and the zero-based index of the current frame as an argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite</em>&nbsp;</td><td>A reference to the sprite which is calling the delegate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame</em>&nbsp;</td><td>The current animation frame number. (0-based)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c11e0d03884e3af7b5040737f2064bd"></a><!-- doxytag: member="SpriteBase::CalcSize" ref="a3c11e0d03884e3af7b5040737f2064bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.CalcSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculates the width and height of the sprite based upon the change in its UV dimensions (autoResize) or on the current camera's disposition (pixelPerfect). </p>

</div>
</div>
<a class="anchor" id="a1645f45e87839994a623d8a70135b000"></a><!-- doxytag: member="SpriteBase::Clear" ref="a1645f45e87839994a623d8a70135b000" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void SpriteBase.Clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets important sprite values to defaults for reuse. </p>

<p>Reimplemented from <a class="el" href="class_sprite_root.html#a28a84d08b092baa1b04336b5b6e33364">SpriteRoot</a>.</p>

<p>Reimplemented in <a class="el" href="class_auto_sprite_base.html#a1e221c6a3483a077d381b276ede895d0">AutoSpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="affa83a7ae3fce4f0137273a59e29ccc6"></a><!-- doxytag: member="SpriteBase::Copy" ref="affa83a7ae3fce4f0137273a59e29ccc6" args="(SpriteRoot s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all the vital attributes of another sprite. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Source sprite to be copied.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f5ee0eb97ebc94d31fc1e31fcb12e68"></a><!-- doxytag: member="SpriteBase::Delete" ref="a1f5ee0eb97ebc94d31fc1e31fcb12e68" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void SpriteBase.Delete </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If non-managed, call <a class="el" href="class_sprite_base.html#a1f5ee0eb97ebc94d31fc1e31fcb12e68" title="If non-managed, call Delete() before destroying this component or the GameObject...">Delete()</a> before destroying this component or the GameObject to which it is attached. Memory leaks can ensue otherwise. </p>

<p>Reimplemented from <a class="el" href="class_sprite_root.html#a53e588efbe27ba78648f402f9c8f6a13">SpriteRoot</a>.</p>

</div>
</div>
<a class="anchor" id="a729b35193db1829b0732151d4de39d05"></a><!-- doxytag: member="SpriteBase::GetCenterPoint" ref="a729b35193db1829b0732151d4de39d05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.GetCenterPoint </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the center point of the sprite, taking into account the actual positions of vertices. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The center point of the sprite.</dd></dl>

</div>
</div>
<a class="anchor" id="afdcc033b3c5c6abcb63c2f3b6dba4596"></a><!-- doxytag: member="SpriteBase::GetStateIndex" ref="afdcc033b3c5c6abcb63c2f3b6dba4596" args="(string stateName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract int SpriteRoot.GetStateIndex </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>stateName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the state with the specified name. -1 if no state matching the specified name is found. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stateName</em>&nbsp;</td><td>The name of the state sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the state, or -1 if no state is found by that name.</dd></dl>

<p>Implemented in <a class="el" href="class_simple_sprite.html#a2b2fe0ab4713fccfb7a61bceb577ffa8">SimpleSprite</a>, and <a class="el" href="class_auto_sprite_base.html#afb7965badcdaa58e6e4a0cbcb0ae8f5b">AutoSpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="a8c337e11b78774a1cc4e2a47d3343c95"></a><!-- doxytag: member="SpriteBase::GetUVs" ref="a8c337e11b78774a1cc4e2a47d3343c95" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Rect SpriteRoot.GetUVs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current UV coordinates of the sprite (before bleed compensation). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Rect containing the sprite's UV coordinates.</dd></dl>

</div>
</div>
<a class="anchor" id="a778d47660b7a9a6695aa77ae24862434"></a><!-- doxytag: member="SpriteBase::GetVertices" ref="a778d47660b7a9a6695aa77ae24862434" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 [] SpriteRoot.GetVertices </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to the sprite's vertices. NOTE: You can only directly modify the sprite's vertices if it is a non-managed sprite. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the sprite's vertices.</dd></dl>

</div>
</div>
<a class="anchor" id="aa1bf525b3837b3456d23d9a03dda766d"></a><!-- doxytag: member="SpriteBase::Hide" ref="aa1bf525b3837b3456d23d9a03dda766d" args="(bool tf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void SpriteBase.Hide </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>tf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hides or displays the sprite by disabling/enabling the sprite's mesh renderer component, or if managed, sets the mesh size to 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tf</em>&nbsp;</td><td>When true, the sprite is hideAtStart, when false, the sprite will be displayed.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sprite_root.html#a013571cc56612f15ca278bd736bae597">SpriteRoot</a>.</p>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#a02f8f0b43f00ca6d645a618ce181aa8f">UIListItem</a>, <a class="el" href="class_u_i_progress_bar.html#aede74d26180959c308452744d7bb29e9">UIProgressBar</a>, <a class="el" href="class_u_i_slider.html#a79bd2be26098ae72f6ab11cc406937c3">UISlider</a>, and <a class="el" href="class_u_i_text_field.html#a6d9e3be1a35690df7db2aebe10dc2ce7">UITextField</a>.</p>

</div>
</div>
<a class="anchor" id="ac98a457ace0eee0fecf82c8e089cc1a5"></a><!-- doxytag: member="SpriteBase::IsAnimating" ref="ac98a457ace0eee0fecf82c8e089cc1a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpriteBase.IsAnimating </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the sprite is currently animating. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the sprite is currently animating, false otherwise.</dd></dl>

</div>
</div>
<a class="anchor" id="abc1b7cd60a2b90903fe4ea925f9c17d1"></a><!-- doxytag: member="SpriteBase::IsHidden" ref="abc1b7cd60a2b90903fe4ea925f9c17d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpriteRoot.IsHidden </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the sprite is currently set to be hideAtStart (whether its mesh renderer component is enabled). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True when hideAtStart, false when set to be displayed.</dd></dl>

</div>
</div>
<a class="anchor" id="a88bdbcaa86cdd2e54908dae42dd79872"></a><!-- doxytag: member="SpriteBase::PauseAnim" ref="a88bdbcaa86cdd2e54908dae42dd79872" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.PauseAnim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pauses the currently-playing animation. </p>

</div>
</div>
<a class="anchor" id="a5ff8725f90b8609efe0f4fff819bac74"></a><!-- doxytag: member="SpriteBase::PixelCoordToUVCoord" ref="a5ff8725f90b8609efe0f4fff819bac74" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelCoordToUVCoord </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The x-coordinate to convert.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The y-coordinate to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The coordinates converted to UV coordinates.</dd></dl>

</div>
</div>
<a class="anchor" id="ae3931a73d6842ec8a98d93b718004975"></a><!-- doxytag: member="SpriteBase::PixelCoordToUVCoord" ref="ae3931a73d6842ec8a98d93b718004975" args="(Vector2 xy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelCoordToUVCoord </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>xy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xy</em>&nbsp;</td><td>The coordinates to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The coordinates converted to UV coordinates.</dd></dl>

</div>
</div>
<a class="anchor" id="a61151a87fd06071bd680ebad9946512e"></a><!-- doxytag: member="SpriteBase::PixelSpaceToUVSpace" ref="a61151a87fd06071bd680ebad9946512e" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelSpaceToUVSpace </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X-value to convert.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y-value to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The values converted to UV space.</dd></dl>

</div>
</div>
<a class="anchor" id="aa9db529bff27dfcdbb0e5e33ed0fbc2e"></a><!-- doxytag: member="SpriteBase::PixelSpaceToUVSpace" ref="aa9db529bff27dfcdbb0e5e33ed0fbc2e" args="(Vector2 xy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelSpaceToUVSpace </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>xy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xy</em>&nbsp;</td><td>The values to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The values converted to UV space.</dd></dl>

</div>
</div>
<a class="anchor" id="aabf07745fff23716a19e591a4d00ecb0"></a><!-- doxytag: member="SpriteBase::PositionOnScreen" ref="aabf07745fff23716a19e591a4d00ecb0" args="(Vector3 pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.PositionOnScreen </td>
          <td>(</td>
          <td class="paramtype">Vector3&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Positions the object using screen coordinates, according to the relativity settings stored in relativeToScreen. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The X and Y screen coordinates where the object should be positioned, as well as the Z coordinate which represents the distance in front of the camera.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a481a3e5c7d1b3370935564ca611fa9fe"></a><!-- doxytag: member="SpriteBase::PositionOnScreen" ref="a481a3e5c7d1b3370935564ca611fa9fe" args="(int x, int y, float depth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.PositionOnScreen </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Positions the object using screen coordinates, according to the relativity settings stored in relativeToScreen. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The number of pixels in the X axis relative to the position specified in relativeToScreen.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The number of pixels in the Y axis relative to the position specified in relativeToScreen.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>The distance the object should be in front of the camera.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09d7f0014281fa0dcdd872c8ad4826a9"></a><!-- doxytag: member="SpriteBase::PositionOnScreen" ref="a09d7f0014281fa0dcdd872c8ad4826a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.PositionOnScreen </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Repositions the object using the existing screen-space settings. </p>

</div>
</div>
<a class="anchor" id="a10f2bcae2161110b2acd5e5b9cca3300"></a><!-- doxytag: member="SpriteBase::RemoveSpriteresizedDelegate" ref="a10f2bcae2161110b2acd5e5b9cca3300" args="(SpriteResizedDelegate del)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.RemoveSpriteresizedDelegate </td>
          <td>(</td>
          <td class="paramtype">SpriteResizedDelegate&nbsp;</td>
          <td class="paramname"> <em>del</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the specified delegate from the list of those to be called when the sprite is resized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>del</em>&nbsp;</td><td>The delegate to be removed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b88afbf9c807629620803fc9e0fb982"></a><!-- doxytag: member="SpriteBase::RevertToStatic" ref="a8b88afbf9c807629620803fc9e0fb982" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.RevertToStatic </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverts the sprite to its static (non-animating) default appearance. </p>

</div>
</div>
<a class="anchor" id="af114f93fa3ad60b469e07346911a5cad"></a><!-- doxytag: member="SpriteBase::SetAnchor" ref="af114f93fa3ad60b469e07346911a5cad" args="(ANCHOR_METHOD a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetAnchor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the anchor method to use. See <a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The anchor method to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a923fa607ba560c946de87c05e6da85c5"></a><!-- doxytag: member="SpriteBase::SetAnimCompleteDelegate" ref="a923fa607ba560c946de87c05e6da85c5" args="(AnimCompleteDelegate del)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.SetAnimCompleteDelegate </td>
          <td>(</td>
          <td class="paramtype">AnimCompleteDelegate&nbsp;</td>
          <td class="paramname"> <em>del</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the delegate to be called upon animation completion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>del</em>&nbsp;</td><td>The delegate to be called when an animation finishes playing.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad31805dac2d46592bc30a95eabf899cb"></a><!-- doxytag: member="SpriteBase::SetAnimFrameDelegate" ref="ad31805dac2d46592bc30a95eabf899cb" args="(AnimFrameDelegate del)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.SetAnimFrameDelegate </td>
          <td>(</td>
          <td class="paramtype">AnimFrameDelegate&nbsp;</td>
          <td class="paramname"> <em>del</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the delegate to be called each frame of animation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>del</em>&nbsp;</td><td>The delegate to be called each frame of animation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9108d36331abd7a6b629b3af7193a85"></a><!-- doxytag: member="SpriteBase::SetBleedCompensation" ref="ab9108d36331abd7a6b629b3af7193a85" args="(Vector2 xy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetBleedCompensation </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>xy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>). </p>

</div>
</div>
<a class="anchor" id="a26d2276f1705f7e61019cf621dd6d2b1"></a><!-- doxytag: member="SpriteBase::SetBleedCompensation" ref="a26d2276f1705f7e61019cf621dd6d2b1" args="(float x, float y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetBleedCompensation </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>). </p>

</div>
</div>
<a class="anchor" id="a4f2fdef32da501a717c69eef466d2135"></a><!-- doxytag: member="SpriteBase::SetCamera" ref="a4f2fdef32da501a717c69eef466d2135" args="(Camera c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.SetCamera </td>
          <td>(</td>
          <td class="paramtype">Camera&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the camera to use when calculating a pixel-perfect sprite size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07898604b8c12c66429d26e8d6fbc3a9"></a><!-- doxytag: member="SpriteBase::SetColor" ref="a07898604b8c12c66429d26e8d6fbc3a9" args="(Color c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.SetColor </td>
          <td>(</td>
          <td class="paramtype">Color&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's color to the specified color. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>Color to shade the sprite.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_u_i_progress_bar.html#aa22b93ae30aac03c4c13eef2b197a78c">UIProgressBar</a>, and <a class="el" href="class_u_i_slider.html#aedec9854823ddef707a741bfb845fd05">UISlider</a>.</p>

</div>
</div>
<a class="anchor" id="a0352fc2f67d2258329f74dcc86bd4d56"></a><!-- doxytag: member="SpriteBase::SetDrawLayer" ref="a0352fc2f67d2258329f74dcc86bd4d56" args="(int layer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetDrawLayer </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>layer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the draw layer of the sprite (only applies to managed sprites). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>layer</em>&nbsp;</td><td>The draw layer of the sprite. Lower values cause an earlier draw order, higher values, a later draw order.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a355b24c10aa7ae976c21e944f3eb22f9"></a><!-- doxytag: member="SpriteBase::SetFrameInfo" ref="a355b24c10aa7ae976c21e944f3eb22f9" args="(SPRITE_FRAME fInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetFrameInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_p_r_i_t_e___f_r_a_m_e.html">SPRITE_FRAME</a>&nbsp;</td>
          <td class="paramname"> <em>fInfo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's frame info, which includes UVs, offsets, etc. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fInfo</em>&nbsp;</td><td>A <a class="el" href="struct_s_p_r_i_t_e___f_r_a_m_e.html">SPRITE_FRAME</a> structure containing the frame info.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ac2df7765bc1baeb3643948024b30a1"></a><!-- doxytag: member="SpriteBase::SetFramerate" ref="a2ac2df7765bc1baeb3643948024b30a1" args="(float fps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.SetFramerate </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>fps</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the framerate at which the current animation plays. NOTE: This only has effect if called AFTER PlayAnim() is called. Otherwise, PlayAnim() sets the framerate to whatever is specified in the animation itself. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fps</em>&nbsp;</td><td>The new framerate, in frames per second.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ae2f4d7bce23b55d8b9d273434623e7"></a><!-- doxytag: member="SpriteBase::SetOffset" ref="a6ae2f4d7bce23b55d8b9d273434623e7" args="(Vector3 o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetOffset </td>
          <td>(</td>
          <td class="paramtype">Vector3&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the offset of the sprite from its GameObject. See <a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457" title="Offsets the sprite, in world space, from the center of its GameObject.">offset</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The offset to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adce43163ad8ad0693c3ea7c109d8408b"></a><!-- doxytag: member="SpriteBase::SetPlane" ref="adce43163ad8ad0693c3ea7c109d8408b" args="(SPRITE_PLANE p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the plane in which the sprite is to be drawn. See: <a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The plane in which the sprite should be drawn.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf9809122c570941ff132a9904dcc93c"></a><!-- doxytag: member="SpriteBase::SetSize" ref="adf9809122c570941ff132a9904dcc93c" args="(float width, float height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetSize </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the physical dimensions of the sprite in the plane selected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width of the sprite in world space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height of the sprite in world space.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8849952300de0c69e246cea541d30e3a"></a><!-- doxytag: member="SpriteBase::SetSpriteResizedDelegate" ref="a8849952300de0c69e246cea541d30e3a" args="(SpriteResizedDelegate del)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.SetSpriteResizedDelegate </td>
          <td>(</td>
          <td class="paramtype">SpriteResizedDelegate&nbsp;</td>
          <td class="paramname"> <em>del</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the delegate to be called when the sprite is resized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>del</em>&nbsp;</td><td>The delegate to be called when the sprite is resized.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4df752403ae612fea2d492cfaf131e0b"></a><!-- doxytag: member="SpriteBase::SetState" ref="a4df752403ae612fea2d492cfaf131e0b" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract void SpriteRoot.SetState </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite to the specified state/animation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The zero-based index of the desired state/animation.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_simple_sprite.html#aa4c5572f4b08ff575565ab2ede85eb74">SimpleSprite</a>, and <a class="el" href="class_auto_sprite_base.html#a1b86d05e9616ec6d21f0c7e6d486f081">AutoSpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="ab7b38c49c508eb9300fa9116a3074ace"></a><!-- doxytag: member="SpriteBase::SetUVs" ref="ab7b38c49c508eb9300fa9116a3074ace" args="(Rect uv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetUVs </td>
          <td>(</td>
          <td class="paramtype">Rect&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's UVs to the specified values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nextFrame</em>&nbsp;</td><td>A Rect containing the new UV coordinates.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2099af0859ccd329e09ff83177811127"></a><!-- doxytag: member="SpriteBase::SetUVsFromPixelCoords" ref="a2099af0859ccd329e09ff83177811127" args="(Rect pxCoords)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetUVsFromPixelCoords </td>
          <td>(</td>
          <td class="paramtype">Rect&nbsp;</td>
          <td class="paramname"> <em>pxCoords</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's UVs from pixel coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pxCoords</em>&nbsp;</td><td>A rect containing the pixel coordinates.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c7f3a0e628f66c612bc80ff4a003021"></a><!-- doxytag: member="SpriteBase::SetWindingOrder" ref="a4c7f3a0e628f66c612bc80ff4a003021" args="(WINDING_ORDER order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetWindingOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>&nbsp;</td>
          <td class="paramname"> <em>order</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the winding order to use. See <a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>The winding order to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a225681fbdb6d79c769c107293949f37f"></a><!-- doxytag: member="SpriteBase::SpriteResizedDelegate" ref="a225681fbdb6d79c769c107293949f37f" args="(float newWidth, float newHeight, SpriteRoot sprite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate void SpriteRoot.SpriteResizedDelegate </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>newWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>newHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>sprite</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines a delegate that can be called upon resizing of the sprite. Use this if you want to adjust colliders, etc, when the sprites dimensions are resized. </p>

</div>
</div>
<a class="anchor" id="aa3d61d10c3119a19ed83376e2269d121"></a><!-- doxytag: member="SpriteBase::StopAnim" ref="aa3d61d10c3119a19ed83376e2269d121" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteBase.StopAnim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops the current animation from playing and resets it to the beginning for playing again. The sprite then reverts to the static image. </p>

<p>Reimplemented in <a class="el" href="class_auto_sprite_base.html#ad169d4a6bc4aaa2d90bf99b0fc887f23">AutoSpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="afabfd5b77d9f2801054d09f70363f955"></a><!-- doxytag: member="SpriteBase::TruncateBottom" ref="afabfd5b77d9f2801054d09f70363f955" args="(float pct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.TruncateBottom </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>pct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncates the bottom edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pct</em>&nbsp;</td><td>The percentage of the sprite to truncate (0-1)</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#a8e028f827cb2dea380cfe8ca2b8dc7ec">UIListItem</a>.</p>

</div>
</div>
<a class="anchor" id="a062df66fcfa288caa1d42cbc949c5224"></a><!-- doxytag: member="SpriteBase::TruncateLeft" ref="a062df66fcfa288caa1d42cbc949c5224" args="(float pct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.TruncateLeft </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>pct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncates the left edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pct</em>&nbsp;</td><td>The percentage of the sprite to truncate (0-1)</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#ade2f5d9cb7bbdcbb36f105f50837229a">UIListItem</a>.</p>

</div>
</div>
<a class="anchor" id="a6b14b0241981a1c7c73e94a293aca4b3"></a><!-- doxytag: member="SpriteBase::TruncateRight" ref="a6b14b0241981a1c7c73e94a293aca4b3" args="(float pct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.TruncateRight </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>pct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncates the right edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pct</em>&nbsp;</td><td>The percentage of the sprite to truncate (0-1)</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#a765cf64080870cda4878bf3220b480df">UIListItem</a>.</p>

</div>
</div>
<a class="anchor" id="acfad33ecdc14bbb036624684d725ce28"></a><!-- doxytag: member="SpriteBase::TruncateTop" ref="acfad33ecdc14bbb036624684d725ce28" args="(float pct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.TruncateTop </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>pct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncates the top edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pct</em>&nbsp;</td><td>The percentage of the sprite to truncate (0-1)</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#ae04233353431516291e0c7d387f959ec">UIListItem</a>.</p>

</div>
</div>
<a class="anchor" id="a97d10b8e450bb429bab82eaeda1bdf12"></a><!-- doxytag: member="SpriteBase::Unclip" ref="a97d10b8e450bb429bab82eaeda1bdf12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.Unclip </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes any clipping that is being applied to the sprite. </p>

<p>Reimplemented in <a class="el" href="class_u_i_progress_bar.html#a9d9a88cd142782d55a77c8dc0b8bc77b">UIProgressBar</a>, <a class="el" href="class_u_i_slider.html#a61455baff8ef2697abaa6b977a514f49">UISlider</a>, and <a class="el" href="class_u_i_text_field.html#a88648369c5ca7409ded3818f3aef9a94">UITextField</a>.</p>

</div>
</div>
<a class="anchor" id="a8477b9dd7e2ac97b2f683ef7f50d1295"></a><!-- doxytag: member="SpriteBase::Untruncate" ref="a8477b9dd7e2ac97b2f683ef7f50d1295" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.Untruncate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes any truncation. </p>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#ac7b0d7763fde1217eb1c354e65ead4ae">UIListItem</a>.</p>

</div>
</div>
<a class="anchor" id="aff78916688134aa447c8071fe552b209"></a><!-- doxytag: member="SpriteBase::UpdateUVs" ref="aff78916688134aa447c8071fe552b209" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.UpdateUVs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies any changes to the UVs to the actual sprite mesh. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a3ea8ab87a750bfafc3cffc34b14f3eba"></a><!-- doxytag: member="SpriteBase::anchor" ref="a3ea8ab87a750bfafc3cffc34b14f3eba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a> <a class="el" href="class_sprite_root.html#a3ea8ab87a750bfafc3cffc34b14f3eba">SpriteRoot.anchor</a> = ANCHOR_METHOD.TEXTURE_OFFSET<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Anchor method to use. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a></dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="ad6bda2f46906d69166ee4b931c3108dd"></a><!-- doxytag: member="SpriteBase::autoResize" ref="ad6bda2f46906d69166ee4b931c3108dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd">SpriteRoot.autoResize</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically resizes the sprite based on its new UV dimensions compared to its previous dimensions. Setting this to true allows you to use non-uniform sized sprites for animation without causing the sprite to appear "squashed" while animating. </p>

</div>
</div>
<a class="anchor" id="a8a9de6bf34778b74f87b3d8e71c3342f"></a><!-- doxytag: member="SpriteBase::bleedCompensation" ref="a8a9de6bf34778b74f87b3d8e71c3342f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f">SpriteRoot.bleedCompensation</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Will contract the UV edges of the sprite by the specified amount to prevent "bleeding" from neighboring pixels, especially when mipmapping. </p>

</div>
</div>
<a class="anchor" id="a206a1db950fc52aaef5b535a7b1a938a"></a><!-- doxytag: member="SpriteBase::color" ref="a206a1db950fc52aaef5b535a7b1a938a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Color <a class="el" href="class_sprite_root.html#a206a1db950fc52aaef5b535a7b1a938a">SpriteRoot.color</a> = Color.white<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The color to be used by all four of the sprite's vertices. This can be used to color, highlight, or fade the sprite. Be sure to use a vertex-colored shader for this to have an effect. </p>

</div>
</div>
<a class="anchor" id="a9d3a230326feff1dc46a065f50d4d5e8"></a><!-- doxytag: member="SpriteBase::defaultAnim" ref="a9d3a230326feff1dc46a065f50d4d5e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_sprite_base.html#a9d3a230326feff1dc46a065f50d4d5e8">SpriteBase.defaultAnim</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Index of the animation to play by default. </p>

</div>
</div>
<a class="anchor" id="a38effd07c9700447283d092a0981e411"></a><!-- doxytag: member="SpriteBase::drawLayer" ref="a38effd07c9700447283d092a0981e411" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_sprite_root.html#a38effd07c9700447283d092a0981e411">SpriteRoot.drawLayer</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The layer in which the sprite will be drawn if managed. </p>

</div>
</div>
<a class="anchor" id="a6bf98fa584df909a7864c4bccfda0b75"></a><!-- doxytag: member="SpriteBase::height" ref="a6bf98fa584df909a7864c4bccfda0b75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_sprite_root.html#a6bf98fa584df909a7864c4bccfda0b75">SpriteRoot.height</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Height of the sprite in world space. </p>

</div>
</div>
<a class="anchor" id="a9905374808829c2c6a15ffeb0170bf52"></a><!-- doxytag: member="SpriteBase::hideAtStart" ref="a9905374808829c2c6a15ffeb0170bf52" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#a9905374808829c2c6a15ffeb0170bf52">SpriteRoot.hideAtStart</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether the sprite will be hideAtStart when it starts. </p>

</div>
</div>
<a class="anchor" id="a27b40cf9515a2d0cae6391fc974c8316"></a><!-- doxytag: member="SpriteBase::managed" ref="a27b40cf9515a2d0cae6391fc974c8316" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#a27b40cf9515a2d0cae6391fc974c8316">SpriteRoot.managed</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When true, the sprite will be managed by the selected sprite manager script. When false, the sprite has its own mesh and will be batched automatically with other sprites (when available - Unity iPhone). </p>

</div>
</div>
<a class="anchor" id="a2ce487455dd3b14e10cfa97a37b3da20"></a><!-- doxytag: member="SpriteBase::manager" ref="a2ce487455dd3b14e10cfa97a37b3da20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_manager.html">SpriteManager</a> <a class="el" href="class_sprite_root.html#a2ce487455dd3b14e10cfa97a37b3da20">SpriteRoot.manager</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reference to the manager which will manage this sprite, provided managed is set to true. </p>

</div>
</div>
<a class="anchor" id="a437424afa712a3ae537768cc0e3a2457"></a><!-- doxytag: member="SpriteBase::offset" ref="a437424afa712a3ae537768cc0e3a2457" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 <a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457">SpriteRoot.offset</a> = new Vector3()<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offsets the sprite, in world space, from the center of its GameObject. </p>

</div>
</div>
<a class="anchor" id="a5be17e1b254ce8a2c0b2f16a0be9a3a3"></a><!-- doxytag: member="SpriteBase::persistent" ref="a5be17e1b254ce8a2c0b2f16a0be9a3a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#a5be17e1b254ce8a2c0b2f16a0be9a3a3">SpriteRoot.persistent</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This must be set to true at design time for the sprite to survive loading a new level. </p>

</div>
</div>
<a class="anchor" id="ae3ebdc6d208c66fcc58fe9bdd1e993fe"></a><!-- doxytag: member="SpriteBase::pixelPerfect" ref="ae3ebdc6d208c66fcc58fe9bdd1e993fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#ae3ebdc6d208c66fcc58fe9bdd1e993fe">SpriteRoot.pixelPerfect</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically sizes the sprite so that it will display pixel-perfect on-screen. NOTE: If you change the orthographic size of the camera or the distance between the sprite and a perspective camera, call <a class="el" href="class_sprite_root.html#a4f2fdef32da501a717c69eef466d2135" title="Sets the camera to use when calculating a pixel-perfect sprite size.">SetCamera()</a> to make the text pixel-perfect again. However, if you want automatic resizing functionality without being pixel-perfect and therefore allowing zooming in and out, use <a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd" title="Automatically resizes the sprite based on its new UV dimensions compared to its previous...">autoResize</a> instead. </p>

</div>
</div>
<a class="anchor" id="a821509586d7b454250d1c7c0b3dd4f74"></a><!-- doxytag: member="SpriteBase::plane" ref="a821509586d7b454250d1c7c0b3dd4f74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a> <a class="el" href="class_sprite_root.html#a821509586d7b454250d1c7c0b3dd4f74">SpriteRoot.plane</a> = SPRITE_PLANE.XY<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The plane in which the sprite will be drawn. </p>

</div>
</div>
<a class="anchor" id="a9c2a037051bc8954928bc97f78c8748b"></a><!-- doxytag: member="SpriteBase::playAnimOnStart" ref="a9c2a037051bc8954928bc97f78c8748b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_base.html#a9c2a037051bc8954928bc97f78c8748b">SpriteBase.playAnimOnStart</a> = false</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When set to true, the sprite will play the default animation (see <a class="el" href="class_sprite_base.html#a9d3a230326feff1dc46a065f50d4d5e8" title="Index of the animation to play by default.">defaultAnim</a>) when the sprite is instantiated. </p>

</div>
</div>
<a class="anchor" id="afeafcd5c4d1b332e1ff9260eee857145"></a><!-- doxytag: member="SpriteBase::width" ref="afeafcd5c4d1b332e1ff9260eee857145" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_sprite_root.html#afeafcd5c4d1b332e1ff9260eee857145">SpriteRoot.width</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Width of the sprite in world space. </p>

</div>
</div>
<a class="anchor" id="a2053a628b672c6b3140ebc2e92264b09"></a><!-- doxytag: member="SpriteBase::winding" ref="a2053a628b672c6b3140ebc2e92264b09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a> <a class="el" href="class_sprite_root.html#a2053a628b672c6b3140ebc2e92264b09">SpriteRoot.winding</a> = WINDING_ORDER.CW<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The winding order of the sprite's polygons - determines the direction the sprite will "face". </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="ae427641cebb3e76e7a2cb2ffdf445836"></a><!-- doxytag: member="SpriteBase::Animating" ref="ae427641cebb3e76e7a2cb2ffdf445836" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpriteBase.Animating<code> [get, set]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Property useful for use with EZ Game Saver. When it gets set, the current animation is started. Include this, along with CurAnimIndex, as a saved property so that any playing animation is resumed. </p>

</div>
</div>
<a class="anchor" id="ab801616440fd6b9500f05dd3565d16b8"></a><!-- doxytag: member="SpriteBase::BottomRight" ref="ab801616440fd6b9500f05dd3565d16b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.BottomRight<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the position of the bottom-right vertex of the sprite after any clipping or trimming. </p>

</div>
</div>
<a class="anchor" id="a222c8253fa3ef1911732d0de73cefb49"></a><!-- doxytag: member="SpriteBase::Clipped" ref="a222c8253fa3ef1911732d0de73cefb49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SpriteRoot.Clipped<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for whether the sprite is to be clipped by any already-specified clipping rect. </p>

<p>Reimplemented in <a class="el" href="class_u_i_progress_bar.html#a07882c6777cea2dd8561c29bdccbbf47">UIProgressBar</a>, <a class="el" href="class_u_i_slider.html#aa6f272ac6012881e6544ba8f313d9ea5">UISlider</a>, and <a class="el" href="class_u_i_text_field.html#ab355658963ab766c09173c5bca91a4b1">UITextField</a>.</p>

</div>
</div>
<a class="anchor" id="a214c7409b2047bd2d533872271a4dc46"></a><!-- doxytag: member="SpriteBase::ClippingRect" ref="a214c7409b2047bd2d533872271a4dc46" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_rect3_d.html">Rect3D</a> SpriteRoot.ClippingRect<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The rect against which the sprite should be clipped. The sprite will be immediately clipped by this rect when set. When setting, the rect should be in world space. </p>

<p>Reimplemented in <a class="el" href="class_u_i_progress_bar.html#a651029ce108c52b8ff5c01a26bbfdfdd">UIProgressBar</a>, <a class="el" href="class_u_i_slider.html#a7388983ed56a8bca2064bbd670b93beb">UISlider</a>, and <a class="el" href="class_u_i_text_field.html#a01044148b9fb87d85fdf8853420547dc">UITextField</a>.</p>

</div>
</div>
<a class="anchor" id="a88bfefa27afedef3c2ab1883fdb2a364"></a><!-- doxytag: member="SpriteBase::CurAnimIndex" ref="a88bfefa27afedef3c2ab1883fdb2a364" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SpriteBase.CurAnimIndex<code> [get, set]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Property useful for use with EZ Game Saver. Include this as a saved property, along with Animating, so that any playing animation is resumed. </p>

</div>
</div>
<a class="anchor" id="ac5a83817fe0a7ccf7910331b2e4eb6aa"></a><!-- doxytag: member="SpriteBase::Managed" ref="ac5a83817fe0a7ccf7910331b2e4eb6aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpriteRoot.Managed<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite to a managed or batched state. </p>

</div>
</div>
<a class="anchor" id="a120de0df612b60e3722b3ef8a759faa5"></a><!-- doxytag: member="SpriteBase::TopLeft" ref="a120de0df612b60e3722b3ef8a759faa5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.TopLeft<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the position of the top-left vertex of the sprite after any clipping or trimming. </p>

</div>
</div>
<a class="anchor" id="af4326379f44bf2e7f8410fb71add0476"></a><!-- doxytag: member="SpriteBase::UnclippedBottomRight" ref="af4326379f44bf2e7f8410fb71add0476" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.UnclippedBottomRight<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The bottom-right corner of the sprite when no clipping or trimming is applied. </p>

</div>
</div>
<a class="anchor" id="a50292aa01cd979d345893d6a81c6f39b"></a><!-- doxytag: member="SpriteBase::UnclippedTopLeft" ref="a50292aa01cd979d345893d6a81c6f39b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.UnclippedTopLeft<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The top-left corner of the sprite when no clipping or trimming is applied. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SpriteBase.cs</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Feb 1 18:27:09 2011 for EZ GUI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
