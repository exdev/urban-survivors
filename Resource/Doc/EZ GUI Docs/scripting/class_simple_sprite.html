<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EZ GUI: SimpleSprite Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="contents">
<h1>SimpleSprite Class Reference</h1><!-- doxytag: class="SimpleSprite" --><!-- doxytag: inherits="SpriteRoot" --><div class="dynheader">
Inheritance diagram for SimpleSprite:</div>
<div class="dynsection">
 <div class="center">
  <img src="class_simple_sprite.gif" usemap="#SimpleSprite_map" alt=""/>
  <map id="SimpleSprite_map" name="SimpleSprite_map">
<area href="class_sprite_root.html" alt="SpriteRoot" shape="rect" coords="0,0,82,24"/>
</map>
 </div>
</div>

<p><a href="class_simple_sprite-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a> </td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#a5ea3cf909cbb432e453c5c97bfe42fdb">Clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets important sprite values to defaults for reuse.  <a href="#a5ea3cf909cbb432e453c5c97bfe42fdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#a307c6e1f7229bbb8dc963a7ce1a05a2e">Setup</a> (float w, float h, Vector2 lowerleftPixel, Vector2 pixeldimensions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the essential elements of a sprite.  <a href="#a307c6e1f7229bbb8dc963a7ce1a05a2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#aecad4d00ae66496df7b03956902d201e">Setup</a> (float w, float h, Vector2 lowerleftPixel, Vector2 pixeldimensions, Material material)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the essential elements of a sprite.  <a href="#aecad4d00ae66496df7b03956902d201e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#a02bf401afae8a92323e110210fc8e70b">Copy</a> (<a class="el" href="class_sprite_root.html">SpriteRoot</a> s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies all the attributes of another sprite.  <a href="#a02bf401afae8a92323e110210fc8e70b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#acfee2b45343682631dfd9dbfea587689">SetLowerLeftPixel</a> (Vector2 lowerLeft)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the lower-left pixel of the sprite. See <a class="el" href="class_simple_sprite.html#a322d834328e3103e531eccf4f86bd3ec" title="Position of the lower-left pixel of the sprite when no animation has been played...">lowerLeftPixel</a>.  <a href="#acfee2b45343682631dfd9dbfea587689"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#a20bb3c8a0672789c6341d88033d4662c">SetLowerLeftPixel</a> (int x, int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the lower-left pixel of the sprite. See <a class="el" href="class_simple_sprite.html#a322d834328e3103e531eccf4f86bd3ec" title="Position of the lower-left pixel of the sprite when no animation has been played...">lowerLeftPixel</a>.  <a href="#a20bb3c8a0672789c6341d88033d4662c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#aa6398941b16582a773a6f69348f12033">SetPixelDimensions</a> (Vector2 size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the pixel dimensions of the sprite. See <a class="el" href="class_simple_sprite.html#a4292c5bcdbc838e06512a65b6efea097" title="Dimensions, in pixels, of the sprite when no animation has been played.">pixelDimensions</a>.  <a href="#aa6398941b16582a773a6f69348f12033"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#a1417768fb4a899a6503ecd4720bc80d5">SetPixelDimensions</a> (int x, int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the pixel dimensions of the sprite. See <a class="el" href="class_simple_sprite.html#a4292c5bcdbc838e06512a65b6efea097" title="Dimensions, in pixels, of the sprite when no animation has been played.">pixelDimensions</a>.  <a href="#a1417768fb4a899a6503ecd4720bc80d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#a2b2fe0ab4713fccfb7a61bceb577ffa8">GetStateIndex</a> (string stateName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the state with the specified name. -1 if no state matching the specified name is found.  <a href="#a2b2fe0ab4713fccfb7a61bceb577ffa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#aa4c5572f4b08ff575565ab2ede85eb74">SetState</a> (int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite to the specified state/animation.  <a href="#aa4c5572f4b08ff575565ab2ede85eb74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a225681fbdb6d79c769c107293949f37f">SpriteResizedDelegate</a> (float newWidth, float newHeight, <a class="el" href="class_sprite_root.html">SpriteRoot</a> sprite)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#affa83a7ae3fce4f0137273a59e29ccc6">Copy</a> (<a class="el" href="class_sprite_root.html">SpriteRoot</a> s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies all the vital attributes of another sprite.  <a href="#affa83a7ae3fce4f0137273a59e29ccc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a53e588efbe27ba78648f402f9c8f6a13">Delete</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If non-managed, call <a class="el" href="class_sprite_root.html#a53e588efbe27ba78648f402f9c8f6a13" title="If non-managed, call Delete() before destroying this component or the GameObject...">Delete()</a> before destroying this component or the GameObject to which it is attached. Memory leaks can ensue otherwise.  <a href="#a53e588efbe27ba78648f402f9c8f6a13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a3c11e0d03884e3af7b5040737f2064bd">CalcSize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recalculates the width and height of the sprite based upon the change in its UV dimensions (autoResize) or on the current camera's disposition (pixelPerfect).  <a href="#a3c11e0d03884e3af7b5040737f2064bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#adf9809122c570941ff132a9904dcc93c">SetSize</a> (float <a class="el" href="class_sprite_root.html#afeafcd5c4d1b332e1ff9260eee857145">width</a>, float <a class="el" href="class_sprite_root.html#a6bf98fa584df909a7864c4bccfda0b75">height</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the physical dimensions of the sprite in the plane selected.  <a href="#adf9809122c570941ff132a9904dcc93c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a6b14b0241981a1c7c73e94a293aca4b3">TruncateRight</a> (float pct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncates the right edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation.  <a href="#a6b14b0241981a1c7c73e94a293aca4b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a062df66fcfa288caa1d42cbc949c5224">TruncateLeft</a> (float pct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncates the left edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation.  <a href="#a062df66fcfa288caa1d42cbc949c5224"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#acfad33ecdc14bbb036624684d725ce28">TruncateTop</a> (float pct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncates the top edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation.  <a href="#acfad33ecdc14bbb036624684d725ce28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#afabfd5b77d9f2801054d09f70363f955">TruncateBottom</a> (float pct)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncates the bottom edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation.  <a href="#afabfd5b77d9f2801054d09f70363f955"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a8477b9dd7e2ac97b2f683ef7f50d1295">Untruncate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes any truncation.  <a href="#a8477b9dd7e2ac97b2f683ef7f50d1295"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a97d10b8e450bb429bab82eaeda1bdf12">Unclip</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes any clipping that is being applied to the sprite.  <a href="#a97d10b8e450bb429bab82eaeda1bdf12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#aff78916688134aa447c8071fe552b209">UpdateUVs</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies any changes to the UVs to the actual sprite mesh.  <a href="#aff78916688134aa447c8071fe552b209"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a07898604b8c12c66429d26e8d6fbc3a9">SetColor</a> (Color c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's color to the specified color.  <a href="#a07898604b8c12c66429d26e8d6fbc3a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a4f2fdef32da501a717c69eef466d2135">SetCamera</a> (Camera c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the camera to use when calculating a pixel-perfect sprite size.  <a href="#a4f2fdef32da501a717c69eef466d2135"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a013571cc56612f15ca278bd736bae597">Hide</a> (bool tf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hides or displays the sprite by disabling/enabling the sprite's mesh renderer component, or if managed, sets the mesh size to 0.  <a href="#a013571cc56612f15ca278bd736bae597"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#abc1b7cd60a2b90903fe4ea925f9c17d1">IsHidden</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the sprite is currently set to be hideAtStart (whether its mesh renderer component is enabled).  <a href="#abc1b7cd60a2b90903fe4ea925f9c17d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a26d2276f1705f7e61019cf621dd6d2b1">SetBleedCompensation</a> (float x, float y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>).  <a href="#a26d2276f1705f7e61019cf621dd6d2b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ab9108d36331abd7a6b629b3af7193a85">SetBleedCompensation</a> (Vector2 xy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>).  <a href="#ab9108d36331abd7a6b629b3af7193a85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#adce43163ad8ad0693c3ea7c109d8408b">SetPlane</a> (<a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a> p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the plane in which the sprite is to be drawn. See: <a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>.  <a href="#adce43163ad8ad0693c3ea7c109d8408b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a4c7f3a0e628f66c612bc80ff4a003021">SetWindingOrder</a> (<a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a> order)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the winding order to use. See <a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>.  <a href="#a4c7f3a0e628f66c612bc80ff4a003021"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a0352fc2f67d2258329f74dcc86bd4d56">SetDrawLayer</a> (int layer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the draw layer of the sprite (only applies to managed sprites).  <a href="#a0352fc2f67d2258329f74dcc86bd4d56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a355b24c10aa7ae976c21e944f3eb22f9">SetFrameInfo</a> (<a class="el" href="struct_s_p_r_i_t_e___f_r_a_m_e.html">SPRITE_FRAME</a> fInfo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's frame info, which includes UVs, offsets, etc.  <a href="#a355b24c10aa7ae976c21e944f3eb22f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ab7b38c49c508eb9300fa9116a3074ace">SetUVs</a> (Rect uv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's UVs to the specified values.  <a href="#ab7b38c49c508eb9300fa9116a3074ace"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a2099af0859ccd329e09ff83177811127">SetUVsFromPixelCoords</a> (Rect pxCoords)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's UVs from pixel coordinates.  <a href="#a2099af0859ccd329e09ff83177811127"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Rect&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a8c337e11b78774a1cc4e2a47d3343c95">GetUVs</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current UV coordinates of the sprite (before bleed compensation).  <a href="#a8c337e11b78774a1cc4e2a47d3343c95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a778d47660b7a9a6695aa77ae24862434">GetVertices</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to the sprite's vertices. NOTE: You can only directly modify the sprite's vertices if it is a non-managed sprite.  <a href="#a778d47660b7a9a6695aa77ae24862434"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a729b35193db1829b0732151d4de39d05">GetCenterPoint</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the center point of the sprite, taking into account the actual positions of vertices.  <a href="#a729b35193db1829b0732151d4de39d05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#af114f93fa3ad60b469e07346911a5cad">SetAnchor</a> (<a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a> a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the anchor method to use. See <a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>.  <a href="#af114f93fa3ad60b469e07346911a5cad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a6ae2f4d7bce23b55d8b9d273434623e7">SetOffset</a> (Vector3 o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the offset of the sprite from its GameObject. See <a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457" title="Offsets the sprite, in world space, from the center of its GameObject.">offset</a>.  <a href="#a6ae2f4d7bce23b55d8b9d273434623e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e">PixelSpaceToUVSpace</a> (Vector2 xy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()!  <a href="#aa9db529bff27dfcdbb0e5e33ed0fbc2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a61151a87fd06071bd680ebad9946512e">PixelSpaceToUVSpace</a> (int x, int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()!  <a href="#a61151a87fd06071bd680ebad9946512e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975">PixelCoordToUVCoord</a> (Vector2 xy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()!  <a href="#ae3931a73d6842ec8a98d93b718004975"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a5ff8725f90b8609efe0f4fff819bac74">PixelCoordToUVCoord</a> (int x, int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()!  <a href="#a5ff8725f90b8609efe0f4fff819bac74"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_simple_sprite.html">SimpleSprite</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#a4790951a55b0a6f6ca86f29411463e8e">Create</a> (string name, Vector3 pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a GameObject and attaches this component type to it.  <a href="#a4790951a55b0a6f6ca86f29411463e8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_simple_sprite.html">SimpleSprite</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#a084c1454451811e7675d62e66986f2c7">Create</a> (string name, Vector3 pos, Quaternion rotation)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a GameObject and attaches this component type to it.  <a href="#a084c1454451811e7675d62e66986f2c7"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#a322d834328e3103e531eccf4f86bd3ec">lowerLeftPixel</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Position of the lower-left pixel of the sprite when no animation has been played.  <a href="#a322d834328e3103e531eccf4f86bd3ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_sprite.html#a4292c5bcdbc838e06512a65b6efea097">pixelDimensions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dimensions, in pixels, of the sprite when no animation has been played.  <a href="#a4292c5bcdbc838e06512a65b6efea097"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a27b40cf9515a2d0cae6391fc974c8316">managed</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When true, the sprite will be managed by the selected sprite manager script. When false, the sprite has its own mesh and will be batched automatically with other sprites (when available - Unity iPhone).  <a href="#a27b40cf9515a2d0cae6391fc974c8316"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_manager.html">SpriteManager</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a2ce487455dd3b14e10cfa97a37b3da20">manager</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference to the manager which will manage this sprite, provided managed is set to true.  <a href="#a2ce487455dd3b14e10cfa97a37b3da20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a38effd07c9700447283d092a0981e411">drawLayer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The layer in which the sprite will be drawn if managed.  <a href="#a38effd07c9700447283d092a0981e411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a5be17e1b254ce8a2c0b2f16a0be9a3a3">persistent</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This must be set to true at design time for the sprite to survive loading a new level.  <a href="#a5be17e1b254ce8a2c0b2f16a0be9a3a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a821509586d7b454250d1c7c0b3dd4f74">plane</a> = SPRITE_PLANE.XY</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The plane in which the sprite will be drawn.  <a href="#a821509586d7b454250d1c7c0b3dd4f74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a2053a628b672c6b3140ebc2e92264b09">winding</a> = WINDING_ORDER.CW</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The winding order of the sprite's polygons - determines the direction the sprite will "face".  <a href="#a2053a628b672c6b3140ebc2e92264b09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#afeafcd5c4d1b332e1ff9260eee857145">width</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Width of the sprite in world space.  <a href="#afeafcd5c4d1b332e1ff9260eee857145"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a6bf98fa584df909a7864c4bccfda0b75">height</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Height of the sprite in world space.  <a href="#a6bf98fa584df909a7864c4bccfda0b75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f">bleedCompensation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Will contract the UV edges of the sprite by the specified amount to prevent "bleeding" from neighboring pixels, especially when mipmapping.  <a href="#a8a9de6bf34778b74f87b3d8e71c3342f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a3ea8ab87a750bfafc3cffc34b14f3eba">anchor</a> = ANCHOR_METHOD.TEXTURE_OFFSET</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Anchor method to use. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a></dd></dl>
<p>.  <a href="#a3ea8ab87a750bfafc3cffc34b14f3eba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ae3ebdc6d208c66fcc58fe9bdd1e993fe">pixelPerfect</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatically sizes the sprite so that it will display pixel-perfect on-screen. NOTE: If you change the orthographic size of the camera or the distance between the sprite and a perspective camera, call <a class="el" href="class_sprite_root.html#a4f2fdef32da501a717c69eef466d2135" title="Sets the camera to use when calculating a pixel-perfect sprite size.">SetCamera()</a> to make the text pixel-perfect again. However, if you want automatic resizing functionality without being pixel-perfect and therefore allowing zooming in and out, use <a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd" title="Automatically resizes the sprite based on its new UV dimensions compared to its previous...">autoResize</a> instead.  <a href="#ae3ebdc6d208c66fcc58fe9bdd1e993fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd">autoResize</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatically resizes the sprite based on its new UV dimensions compared to its previous dimensions. Setting this to true allows you to use non-uniform sized sprites for animation without causing the sprite to appear "squashed" while animating.  <a href="#ad6bda2f46906d69166ee4b931c3108dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457">offset</a> = new Vector3()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Offsets the sprite, in world space, from the center of its GameObject.  <a href="#a437424afa712a3ae537768cc0e3a2457"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Color&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a206a1db950fc52aaef5b535a7b1a938a">color</a> = Color.white</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The color to be used by all four of the sprite's vertices. This can be used to color, highlight, or fade the sprite. Be sure to use a vertex-colored shader for this to have an effect.  <a href="#a206a1db950fc52aaef5b535a7b1a938a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a9905374808829c2c6a15ffeb0170bf52">hideAtStart</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the sprite will be hideAtStart when it starts.  <a href="#a9905374808829c2c6a15ffeb0170bf52"></a><br/></td></tr>
<tr><td colspan="2"><h2>Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ac5a83817fe0a7ccf7910331b2e4eb6aa">Managed</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite to a managed or batched state.  <a href="#ac5a83817fe0a7ccf7910331b2e4eb6aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_rect3_d.html">Rect3D</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a214c7409b2047bd2d533872271a4dc46">ClippingRect</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rect against which the sprite should be clipped. The sprite will be immediately clipped by this rect when set. When setting, the rect should be in world space.  <a href="#a214c7409b2047bd2d533872271a4dc46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a222c8253fa3ef1911732d0de73cefb49">Clipped</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for whether the sprite is to be clipped by any already-specified clipping rect.  <a href="#a222c8253fa3ef1911732d0de73cefb49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a50292aa01cd979d345893d6a81c6f39b">UnclippedTopLeft</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The top-left corner of the sprite when no clipping or trimming is applied.  <a href="#a50292aa01cd979d345893d6a81c6f39b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#af4326379f44bf2e7f8410fb71add0476">UnclippedBottomRight</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bottom-right corner of the sprite when no clipping or trimming is applied.  <a href="#af4326379f44bf2e7f8410fb71add0476"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a120de0df612b60e3722b3ef8a759faa5">TopLeft</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the position of the top-left vertex of the sprite after any clipping or trimming.  <a href="#a120de0df612b60e3722b3ef8a759faa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ab801616440fd6b9500f05dd3565d16b8">BottomRight</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the position of the bottom-right vertex of the sprite after any clipping or trimming.  <a href="#ab801616440fd6b9500f05dd3565d16b8"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Defines a simple, non-packable, non-animating sprite. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a79b7138073d866284a170e4d8b3a9217"></a><!-- doxytag: member="SimpleSprite::ANCHOR_METHOD" ref="a79b7138073d866284a170e4d8b3a9217" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">SpriteRoot::ANCHOR_METHOD</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The anchoring scheme of a sprite. The anchor point is the point on the sprite that will remain stationary when the sprite's size changes. For a health bar that "grows" to the right while its left edge remains stationary, you would use UPPER_LEFT, MIDDLE_LEFT, or BOTTOM_LEFT.</p>
<p>For a health bar that "grows" upward while the bottom edge remains stationary, you would use BOTTOM_LEFT, BOTTOM_CENTER, or BOTTOM_RIGHT.</p>

</div>
</div>
<a class="anchor" id="a4f354b80a58bab8f31f7966750800e57"></a><!-- doxytag: member="SimpleSprite::SPRITE_PLANE" ref="a4f354b80a58bab8f31f7966750800e57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SpriteRoot::SPRITE_PLANE</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The plane in which a sprite should be drawn. </p>

</div>
</div>
<a class="anchor" id="aa6a06ad89a880accb25794e862733074"></a><!-- doxytag: member="SimpleSprite::WINDING_ORDER" ref="aa6a06ad89a880accb25794e862733074" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">SpriteRoot::WINDING_ORDER</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines which way the polygons of a sprite should be wound. The two options are clock-wise (CW) and counter clock-wise (CCW). These determine the direction the sprite will "face". </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3c11e0d03884e3af7b5040737f2064bd"></a><!-- doxytag: member="SimpleSprite::CalcSize" ref="a3c11e0d03884e3af7b5040737f2064bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.CalcSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculates the width and height of the sprite based upon the change in its UV dimensions (autoResize) or on the current camera's disposition (pixelPerfect). </p>

</div>
</div>
<a class="anchor" id="a5ea3cf909cbb432e453c5c97bfe42fdb"></a><!-- doxytag: member="SimpleSprite::Clear" ref="a5ea3cf909cbb432e453c5c97bfe42fdb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void SimpleSprite.Clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets important sprite values to defaults for reuse. </p>

<p>Reimplemented from <a class="el" href="class_sprite_root.html#a28a84d08b092baa1b04336b5b6e33364">SpriteRoot</a>.</p>

</div>
</div>
<a class="anchor" id="affa83a7ae3fce4f0137273a59e29ccc6"></a><!-- doxytag: member="SimpleSprite::Copy" ref="affa83a7ae3fce4f0137273a59e29ccc6" args="(SpriteRoot s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all the vital attributes of another sprite. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Source sprite to be copied.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02bf401afae8a92323e110210fc8e70b"></a><!-- doxytag: member="SimpleSprite::Copy" ref="a02bf401afae8a92323e110210fc8e70b" args="(SpriteRoot s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void SimpleSprite.Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all the attributes of another sprite. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A reference to the sprite to be copied.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a084c1454451811e7675d62e66986f2c7"></a><!-- doxytag: member="SimpleSprite::Create" ref="a084c1454451811e7675d62e66986f2c7" args="(string name, Vector3 pos, Quaternion rotation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_simple_sprite.html">SimpleSprite</a> SimpleSprite.Create </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Quaternion&nbsp;</td>
          <td class="paramname"> <em>rotation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a GameObject and attaches this component type to it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name to give to the new GameObject.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position, in world space, where the new object should be created.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotation</em>&nbsp;</td><td>Rotation of the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a reference to the component.</dd></dl>

</div>
</div>
<a class="anchor" id="a4790951a55b0a6f6ca86f29411463e8e"></a><!-- doxytag: member="SimpleSprite::Create" ref="a4790951a55b0a6f6ca86f29411463e8e" args="(string name, Vector3 pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_simple_sprite.html">SimpleSprite</a> SimpleSprite.Create </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a GameObject and attaches this component type to it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name to give to the new GameObject.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position, in world space, where the new object should be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a reference to the component.</dd></dl>

</div>
</div>
<a class="anchor" id="a53e588efbe27ba78648f402f9c8f6a13"></a><!-- doxytag: member="SimpleSprite::Delete" ref="a53e588efbe27ba78648f402f9c8f6a13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.Delete </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If non-managed, call <a class="el" href="class_sprite_root.html#a53e588efbe27ba78648f402f9c8f6a13" title="If non-managed, call Delete() before destroying this component or the GameObject...">Delete()</a> before destroying this component or the GameObject to which it is attached. Memory leaks can ensue otherwise. </p>

<p>Reimplemented in <a class="el" href="class_sprite_base.html#a1f5ee0eb97ebc94d31fc1e31fcb12e68">SpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="a729b35193db1829b0732151d4de39d05"></a><!-- doxytag: member="SimpleSprite::GetCenterPoint" ref="a729b35193db1829b0732151d4de39d05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.GetCenterPoint </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the center point of the sprite, taking into account the actual positions of vertices. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The center point of the sprite.</dd></dl>

</div>
</div>
<a class="anchor" id="a2b2fe0ab4713fccfb7a61bceb577ffa8"></a><!-- doxytag: member="SimpleSprite::GetStateIndex" ref="a2b2fe0ab4713fccfb7a61bceb577ffa8" args="(string stateName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override int SimpleSprite.GetStateIndex </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>stateName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the state with the specified name. -1 if no state matching the specified name is found. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stateName</em>&nbsp;</td><td>The name of the state sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the state, or -1 if no state is found by that name.</dd></dl>

<p>Implements <a class="el" href="class_sprite_root.html#afdcc033b3c5c6abcb63c2f3b6dba4596">SpriteRoot</a>.</p>

</div>
</div>
<a class="anchor" id="a8c337e11b78774a1cc4e2a47d3343c95"></a><!-- doxytag: member="SimpleSprite::GetUVs" ref="a8c337e11b78774a1cc4e2a47d3343c95" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Rect SpriteRoot.GetUVs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current UV coordinates of the sprite (before bleed compensation). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Rect containing the sprite's UV coordinates.</dd></dl>

</div>
</div>
<a class="anchor" id="a778d47660b7a9a6695aa77ae24862434"></a><!-- doxytag: member="SimpleSprite::GetVertices" ref="a778d47660b7a9a6695aa77ae24862434" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 [] SpriteRoot.GetVertices </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to the sprite's vertices. NOTE: You can only directly modify the sprite's vertices if it is a non-managed sprite. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the sprite's vertices.</dd></dl>

</div>
</div>
<a class="anchor" id="a013571cc56612f15ca278bd736bae597"></a><!-- doxytag: member="SimpleSprite::Hide" ref="a013571cc56612f15ca278bd736bae597" args="(bool tf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.Hide </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>tf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hides or displays the sprite by disabling/enabling the sprite's mesh renderer component, or if managed, sets the mesh size to 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tf</em>&nbsp;</td><td>When true, the sprite is hideAtStart, when false, the sprite will be displayed.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#a02f8f0b43f00ca6d645a618ce181aa8f">UIListItem</a>, <a class="el" href="class_u_i_progress_bar.html#aede74d26180959c308452744d7bb29e9">UIProgressBar</a>, <a class="el" href="class_u_i_slider.html#a79bd2be26098ae72f6ab11cc406937c3">UISlider</a>, <a class="el" href="class_u_i_text_field.html#a6d9e3be1a35690df7db2aebe10dc2ce7">UITextField</a>, and <a class="el" href="class_sprite_base.html#aa1bf525b3837b3456d23d9a03dda766d">SpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="abc1b7cd60a2b90903fe4ea925f9c17d1"></a><!-- doxytag: member="SimpleSprite::IsHidden" ref="abc1b7cd60a2b90903fe4ea925f9c17d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpriteRoot.IsHidden </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the sprite is currently set to be hideAtStart (whether its mesh renderer component is enabled). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True when hideAtStart, false when set to be displayed.</dd></dl>

</div>
</div>
<a class="anchor" id="a5ff8725f90b8609efe0f4fff819bac74"></a><!-- doxytag: member="SimpleSprite::PixelCoordToUVCoord" ref="a5ff8725f90b8609efe0f4fff819bac74" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelCoordToUVCoord </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The x-coordinate to convert.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The y-coordinate to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The coordinates converted to UV coordinates.</dd></dl>

</div>
</div>
<a class="anchor" id="ae3931a73d6842ec8a98d93b718004975"></a><!-- doxytag: member="SimpleSprite::PixelCoordToUVCoord" ref="ae3931a73d6842ec8a98d93b718004975" args="(Vector2 xy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelCoordToUVCoord </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>xy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xy</em>&nbsp;</td><td>The coordinates to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The coordinates converted to UV coordinates.</dd></dl>

</div>
</div>
<a class="anchor" id="a61151a87fd06071bd680ebad9946512e"></a><!-- doxytag: member="SimpleSprite::PixelSpaceToUVSpace" ref="a61151a87fd06071bd680ebad9946512e" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelSpaceToUVSpace </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X-value to convert.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y-value to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The values converted to UV space.</dd></dl>

</div>
</div>
<a class="anchor" id="aa9db529bff27dfcdbb0e5e33ed0fbc2e"></a><!-- doxytag: member="SimpleSprite::PixelSpaceToUVSpace" ref="aa9db529bff27dfcdbb0e5e33ed0fbc2e" args="(Vector2 xy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelSpaceToUVSpace </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>xy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xy</em>&nbsp;</td><td>The values to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The values converted to UV space.</dd></dl>

</div>
</div>
<a class="anchor" id="af114f93fa3ad60b469e07346911a5cad"></a><!-- doxytag: member="SimpleSprite::SetAnchor" ref="af114f93fa3ad60b469e07346911a5cad" args="(ANCHOR_METHOD a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetAnchor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the anchor method to use. See <a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The anchor method to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9108d36331abd7a6b629b3af7193a85"></a><!-- doxytag: member="SimpleSprite::SetBleedCompensation" ref="ab9108d36331abd7a6b629b3af7193a85" args="(Vector2 xy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetBleedCompensation </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>xy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>). </p>

</div>
</div>
<a class="anchor" id="a26d2276f1705f7e61019cf621dd6d2b1"></a><!-- doxytag: member="SimpleSprite::SetBleedCompensation" ref="a26d2276f1705f7e61019cf621dd6d2b1" args="(float x, float y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetBleedCompensation </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>). </p>

</div>
</div>
<a class="anchor" id="a4f2fdef32da501a717c69eef466d2135"></a><!-- doxytag: member="SimpleSprite::SetCamera" ref="a4f2fdef32da501a717c69eef466d2135" args="(Camera c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.SetCamera </td>
          <td>(</td>
          <td class="paramtype">Camera&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the camera to use when calculating a pixel-perfect sprite size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07898604b8c12c66429d26e8d6fbc3a9"></a><!-- doxytag: member="SimpleSprite::SetColor" ref="a07898604b8c12c66429d26e8d6fbc3a9" args="(Color c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.SetColor </td>
          <td>(</td>
          <td class="paramtype">Color&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's color to the specified color. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>Color to shade the sprite.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_u_i_progress_bar.html#aa22b93ae30aac03c4c13eef2b197a78c">UIProgressBar</a>, and <a class="el" href="class_u_i_slider.html#aedec9854823ddef707a741bfb845fd05">UISlider</a>.</p>

</div>
</div>
<a class="anchor" id="a0352fc2f67d2258329f74dcc86bd4d56"></a><!-- doxytag: member="SimpleSprite::SetDrawLayer" ref="a0352fc2f67d2258329f74dcc86bd4d56" args="(int layer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetDrawLayer </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>layer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the draw layer of the sprite (only applies to managed sprites). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>layer</em>&nbsp;</td><td>The draw layer of the sprite. Lower values cause an earlier draw order, higher values, a later draw order.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a355b24c10aa7ae976c21e944f3eb22f9"></a><!-- doxytag: member="SimpleSprite::SetFrameInfo" ref="a355b24c10aa7ae976c21e944f3eb22f9" args="(SPRITE_FRAME fInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetFrameInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_p_r_i_t_e___f_r_a_m_e.html">SPRITE_FRAME</a>&nbsp;</td>
          <td class="paramname"> <em>fInfo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's frame info, which includes UVs, offsets, etc. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fInfo</em>&nbsp;</td><td>A <a class="el" href="struct_s_p_r_i_t_e___f_r_a_m_e.html">SPRITE_FRAME</a> structure containing the frame info.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20bb3c8a0672789c6341d88033d4662c"></a><!-- doxytag: member="SimpleSprite::SetLowerLeftPixel" ref="a20bb3c8a0672789c6341d88033d4662c" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleSprite.SetLowerLeftPixel </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the lower-left pixel of the sprite. See <a class="el" href="class_simple_sprite.html#a322d834328e3103e531eccf4f86bd3ec" title="Position of the lower-left pixel of the sprite when no animation has been played...">lowerLeftPixel</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>X pixel coordinate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Y pixel coordinate.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfee2b45343682631dfd9dbfea587689"></a><!-- doxytag: member="SimpleSprite::SetLowerLeftPixel" ref="acfee2b45343682631dfd9dbfea587689" args="(Vector2 lowerLeft)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleSprite.SetLowerLeftPixel </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>lowerLeft</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the lower-left pixel of the sprite. See <a class="el" href="class_simple_sprite.html#a322d834328e3103e531eccf4f86bd3ec" title="Position of the lower-left pixel of the sprite when no animation has been played...">lowerLeftPixel</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lowerLeft</em>&nbsp;</td><td>Pixel coordinate of the lower-left corner of the sprite.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ae2f4d7bce23b55d8b9d273434623e7"></a><!-- doxytag: member="SimpleSprite::SetOffset" ref="a6ae2f4d7bce23b55d8b9d273434623e7" args="(Vector3 o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetOffset </td>
          <td>(</td>
          <td class="paramtype">Vector3&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the offset of the sprite from its GameObject. See <a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457" title="Offsets the sprite, in world space, from the center of its GameObject.">offset</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The offset to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1417768fb4a899a6503ecd4720bc80d5"></a><!-- doxytag: member="SimpleSprite::SetPixelDimensions" ref="a1417768fb4a899a6503ecd4720bc80d5" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleSprite.SetPixelDimensions </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the pixel dimensions of the sprite. See <a class="el" href="class_simple_sprite.html#a4292c5bcdbc838e06512a65b6efea097" title="Dimensions, in pixels, of the sprite when no animation has been played.">pixelDimensions</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>X size in pixels.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Y size in pixels.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6398941b16582a773a6f69348f12033"></a><!-- doxytag: member="SimpleSprite::SetPixelDimensions" ref="aa6398941b16582a773a6f69348f12033" args="(Vector2 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleSprite.SetPixelDimensions </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the pixel dimensions of the sprite. See <a class="el" href="class_simple_sprite.html#a4292c5bcdbc838e06512a65b6efea097" title="Dimensions, in pixels, of the sprite when no animation has been played.">pixelDimensions</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Dimensions of the sprite in pixels.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adce43163ad8ad0693c3ea7c109d8408b"></a><!-- doxytag: member="SimpleSprite::SetPlane" ref="adce43163ad8ad0693c3ea7c109d8408b" args="(SPRITE_PLANE p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the plane in which the sprite is to be drawn. See: <a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The plane in which the sprite should be drawn.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf9809122c570941ff132a9904dcc93c"></a><!-- doxytag: member="SimpleSprite::SetSize" ref="adf9809122c570941ff132a9904dcc93c" args="(float width, float height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetSize </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the physical dimensions of the sprite in the plane selected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width of the sprite in world space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height of the sprite in world space.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4c5572f4b08ff575565ab2ede85eb74"></a><!-- doxytag: member="SimpleSprite::SetState" ref="aa4c5572f4b08ff575565ab2ede85eb74" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void SimpleSprite.SetState </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite to the specified state/animation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The zero-based index of the desired state/animation.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_sprite_root.html#a4df752403ae612fea2d492cfaf131e0b">SpriteRoot</a>.</p>

</div>
</div>
<a class="anchor" id="aecad4d00ae66496df7b03956902d201e"></a><!-- doxytag: member="SimpleSprite::Setup" ref="aecad4d00ae66496df7b03956902d201e" args="(float w, float h, Vector2 lowerleftPixel, Vector2 pixeldimensions, Material material)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleSprite.Setup </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>lowerleftPixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>pixeldimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Material&nbsp;</td>
          <td class="paramname"> <em>material</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets up the essential elements of a sprite. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>The width, in local space, of the sprite.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The height, in local space, of the sprite.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lowerleftPixel</em>&nbsp;</td><td>The coordinate of the lower-left pixel of the desired sprite on the sprite atlas.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixeldimensions</em>&nbsp;</td><td>The X and Y dimensions, in pixels, of the sprite.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>material</em>&nbsp;</td><td>The material to use for the sprite.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a307c6e1f7229bbb8dc963a7ce1a05a2e"></a><!-- doxytag: member="SimpleSprite::Setup" ref="a307c6e1f7229bbb8dc963a7ce1a05a2e" args="(float w, float h, Vector2 lowerleftPixel, Vector2 pixeldimensions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleSprite.Setup </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>lowerleftPixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>pixeldimensions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets up the essential elements of a sprite. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>The width, in local space, of the sprite.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The height, in local space, of the sprite.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lowerleftPixel</em>&nbsp;</td><td>The coordinate of the lower-left pixel of the desired sprite on the sprite atlas.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixeldimensions</em>&nbsp;</td><td>The X and Y dimensions, in pixels, of the sprite.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7b38c49c508eb9300fa9116a3074ace"></a><!-- doxytag: member="SimpleSprite::SetUVs" ref="ab7b38c49c508eb9300fa9116a3074ace" args="(Rect uv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetUVs </td>
          <td>(</td>
          <td class="paramtype">Rect&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's UVs to the specified values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nextFrame</em>&nbsp;</td><td>A Rect containing the new UV coordinates.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2099af0859ccd329e09ff83177811127"></a><!-- doxytag: member="SimpleSprite::SetUVsFromPixelCoords" ref="a2099af0859ccd329e09ff83177811127" args="(Rect pxCoords)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetUVsFromPixelCoords </td>
          <td>(</td>
          <td class="paramtype">Rect&nbsp;</td>
          <td class="paramname"> <em>pxCoords</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's UVs from pixel coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pxCoords</em>&nbsp;</td><td>A rect containing the pixel coordinates.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c7f3a0e628f66c612bc80ff4a003021"></a><!-- doxytag: member="SimpleSprite::SetWindingOrder" ref="a4c7f3a0e628f66c612bc80ff4a003021" args="(WINDING_ORDER order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetWindingOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>&nbsp;</td>
          <td class="paramname"> <em>order</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the winding order to use. See <a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>The winding order to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a225681fbdb6d79c769c107293949f37f"></a><!-- doxytag: member="SimpleSprite::SpriteResizedDelegate" ref="a225681fbdb6d79c769c107293949f37f" args="(float newWidth, float newHeight, SpriteRoot sprite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate void SpriteRoot.SpriteResizedDelegate </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>newWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>newHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>sprite</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines a delegate that can be called upon resizing of the sprite. Use this if you want to adjust colliders, etc, when the sprites dimensions are resized. </p>

</div>
</div>
<a class="anchor" id="afabfd5b77d9f2801054d09f70363f955"></a><!-- doxytag: member="SimpleSprite::TruncateBottom" ref="afabfd5b77d9f2801054d09f70363f955" args="(float pct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.TruncateBottom </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>pct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncates the bottom edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pct</em>&nbsp;</td><td>The percentage of the sprite to truncate (0-1)</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#a8e028f827cb2dea380cfe8ca2b8dc7ec">UIListItem</a>.</p>

</div>
</div>
<a class="anchor" id="a062df66fcfa288caa1d42cbc949c5224"></a><!-- doxytag: member="SimpleSprite::TruncateLeft" ref="a062df66fcfa288caa1d42cbc949c5224" args="(float pct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.TruncateLeft </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>pct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncates the left edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pct</em>&nbsp;</td><td>The percentage of the sprite to truncate (0-1)</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#ade2f5d9cb7bbdcbb36f105f50837229a">UIListItem</a>.</p>

</div>
</div>
<a class="anchor" id="a6b14b0241981a1c7c73e94a293aca4b3"></a><!-- doxytag: member="SimpleSprite::TruncateRight" ref="a6b14b0241981a1c7c73e94a293aca4b3" args="(float pct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.TruncateRight </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>pct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncates the right edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pct</em>&nbsp;</td><td>The percentage of the sprite to truncate (0-1)</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#a765cf64080870cda4878bf3220b480df">UIListItem</a>.</p>

</div>
</div>
<a class="anchor" id="acfad33ecdc14bbb036624684d725ce28"></a><!-- doxytag: member="SimpleSprite::TruncateTop" ref="acfad33ecdc14bbb036624684d725ce28" args="(float pct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.TruncateTop </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>pct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncates the top edge of the sprite to the specified percentage. 1 == no truncation 0 == complete truncation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pct</em>&nbsp;</td><td>The percentage of the sprite to truncate (0-1)</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#ae04233353431516291e0c7d387f959ec">UIListItem</a>.</p>

</div>
</div>
<a class="anchor" id="a97d10b8e450bb429bab82eaeda1bdf12"></a><!-- doxytag: member="SimpleSprite::Unclip" ref="a97d10b8e450bb429bab82eaeda1bdf12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.Unclip </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes any clipping that is being applied to the sprite. </p>

<p>Reimplemented in <a class="el" href="class_u_i_progress_bar.html#a9d9a88cd142782d55a77c8dc0b8bc77b">UIProgressBar</a>, <a class="el" href="class_u_i_slider.html#a61455baff8ef2697abaa6b977a514f49">UISlider</a>, and <a class="el" href="class_u_i_text_field.html#a88648369c5ca7409ded3818f3aef9a94">UITextField</a>.</p>

</div>
</div>
<a class="anchor" id="a8477b9dd7e2ac97b2f683ef7f50d1295"></a><!-- doxytag: member="SimpleSprite::Untruncate" ref="a8477b9dd7e2ac97b2f683ef7f50d1295" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.Untruncate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes any truncation. </p>

<p>Reimplemented in <a class="el" href="class_u_i_list_item.html#ac7b0d7763fde1217eb1c354e65ead4ae">UIListItem</a>.</p>

</div>
</div>
<a class="anchor" id="aff78916688134aa447c8071fe552b209"></a><!-- doxytag: member="SimpleSprite::UpdateUVs" ref="aff78916688134aa447c8071fe552b209" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.UpdateUVs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies any changes to the UVs to the actual sprite mesh. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a3ea8ab87a750bfafc3cffc34b14f3eba"></a><!-- doxytag: member="SimpleSprite::anchor" ref="a3ea8ab87a750bfafc3cffc34b14f3eba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a> <a class="el" href="class_sprite_root.html#a3ea8ab87a750bfafc3cffc34b14f3eba">SpriteRoot.anchor</a> = ANCHOR_METHOD.TEXTURE_OFFSET<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Anchor method to use. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a></dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="ad6bda2f46906d69166ee4b931c3108dd"></a><!-- doxytag: member="SimpleSprite::autoResize" ref="ad6bda2f46906d69166ee4b931c3108dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd">SpriteRoot.autoResize</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically resizes the sprite based on its new UV dimensions compared to its previous dimensions. Setting this to true allows you to use non-uniform sized sprites for animation without causing the sprite to appear "squashed" while animating. </p>

</div>
</div>
<a class="anchor" id="a8a9de6bf34778b74f87b3d8e71c3342f"></a><!-- doxytag: member="SimpleSprite::bleedCompensation" ref="a8a9de6bf34778b74f87b3d8e71c3342f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f">SpriteRoot.bleedCompensation</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Will contract the UV edges of the sprite by the specified amount to prevent "bleeding" from neighboring pixels, especially when mipmapping. </p>

</div>
</div>
<a class="anchor" id="a206a1db950fc52aaef5b535a7b1a938a"></a><!-- doxytag: member="SimpleSprite::color" ref="a206a1db950fc52aaef5b535a7b1a938a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Color <a class="el" href="class_sprite_root.html#a206a1db950fc52aaef5b535a7b1a938a">SpriteRoot.color</a> = Color.white<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The color to be used by all four of the sprite's vertices. This can be used to color, highlight, or fade the sprite. Be sure to use a vertex-colored shader for this to have an effect. </p>

</div>
</div>
<a class="anchor" id="a38effd07c9700447283d092a0981e411"></a><!-- doxytag: member="SimpleSprite::drawLayer" ref="a38effd07c9700447283d092a0981e411" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_sprite_root.html#a38effd07c9700447283d092a0981e411">SpriteRoot.drawLayer</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The layer in which the sprite will be drawn if managed. </p>

</div>
</div>
<a class="anchor" id="a6bf98fa584df909a7864c4bccfda0b75"></a><!-- doxytag: member="SimpleSprite::height" ref="a6bf98fa584df909a7864c4bccfda0b75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_sprite_root.html#a6bf98fa584df909a7864c4bccfda0b75">SpriteRoot.height</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Height of the sprite in world space. </p>

</div>
</div>
<a class="anchor" id="a9905374808829c2c6a15ffeb0170bf52"></a><!-- doxytag: member="SimpleSprite::hideAtStart" ref="a9905374808829c2c6a15ffeb0170bf52" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#a9905374808829c2c6a15ffeb0170bf52">SpriteRoot.hideAtStart</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether the sprite will be hideAtStart when it starts. </p>

</div>
</div>
<a class="anchor" id="a322d834328e3103e531eccf4f86bd3ec"></a><!-- doxytag: member="SimpleSprite::lowerLeftPixel" ref="a322d834328e3103e531eccf4f86bd3ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 <a class="el" href="class_simple_sprite.html#a322d834328e3103e531eccf4f86bd3ec">SimpleSprite.lowerLeftPixel</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Position of the lower-left pixel of the sprite when no animation has been played. </p>

</div>
</div>
<a class="anchor" id="a27b40cf9515a2d0cae6391fc974c8316"></a><!-- doxytag: member="SimpleSprite::managed" ref="a27b40cf9515a2d0cae6391fc974c8316" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#a27b40cf9515a2d0cae6391fc974c8316">SpriteRoot.managed</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When true, the sprite will be managed by the selected sprite manager script. When false, the sprite has its own mesh and will be batched automatically with other sprites (when available - Unity iPhone). </p>

</div>
</div>
<a class="anchor" id="a2ce487455dd3b14e10cfa97a37b3da20"></a><!-- doxytag: member="SimpleSprite::manager" ref="a2ce487455dd3b14e10cfa97a37b3da20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_manager.html">SpriteManager</a> <a class="el" href="class_sprite_root.html#a2ce487455dd3b14e10cfa97a37b3da20">SpriteRoot.manager</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reference to the manager which will manage this sprite, provided managed is set to true. </p>

</div>
</div>
<a class="anchor" id="a437424afa712a3ae537768cc0e3a2457"></a><!-- doxytag: member="SimpleSprite::offset" ref="a437424afa712a3ae537768cc0e3a2457" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 <a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457">SpriteRoot.offset</a> = new Vector3()<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offsets the sprite, in world space, from the center of its GameObject. </p>

</div>
</div>
<a class="anchor" id="a5be17e1b254ce8a2c0b2f16a0be9a3a3"></a><!-- doxytag: member="SimpleSprite::persistent" ref="a5be17e1b254ce8a2c0b2f16a0be9a3a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#a5be17e1b254ce8a2c0b2f16a0be9a3a3">SpriteRoot.persistent</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This must be set to true at design time for the sprite to survive loading a new level. </p>

</div>
</div>
<a class="anchor" id="a4292c5bcdbc838e06512a65b6efea097"></a><!-- doxytag: member="SimpleSprite::pixelDimensions" ref="a4292c5bcdbc838e06512a65b6efea097" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 <a class="el" href="class_simple_sprite.html#a4292c5bcdbc838e06512a65b6efea097">SimpleSprite.pixelDimensions</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dimensions, in pixels, of the sprite when no animation has been played. </p>

</div>
</div>
<a class="anchor" id="ae3ebdc6d208c66fcc58fe9bdd1e993fe"></a><!-- doxytag: member="SimpleSprite::pixelPerfect" ref="ae3ebdc6d208c66fcc58fe9bdd1e993fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#ae3ebdc6d208c66fcc58fe9bdd1e993fe">SpriteRoot.pixelPerfect</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically sizes the sprite so that it will display pixel-perfect on-screen. NOTE: If you change the orthographic size of the camera or the distance between the sprite and a perspective camera, call <a class="el" href="class_sprite_root.html#a4f2fdef32da501a717c69eef466d2135" title="Sets the camera to use when calculating a pixel-perfect sprite size.">SetCamera()</a> to make the text pixel-perfect again. However, if you want automatic resizing functionality without being pixel-perfect and therefore allowing zooming in and out, use <a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd" title="Automatically resizes the sprite based on its new UV dimensions compared to its previous...">autoResize</a> instead. </p>

</div>
</div>
<a class="anchor" id="a821509586d7b454250d1c7c0b3dd4f74"></a><!-- doxytag: member="SimpleSprite::plane" ref="a821509586d7b454250d1c7c0b3dd4f74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a> <a class="el" href="class_sprite_root.html#a821509586d7b454250d1c7c0b3dd4f74">SpriteRoot.plane</a> = SPRITE_PLANE.XY<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The plane in which the sprite will be drawn. </p>

</div>
</div>
<a class="anchor" id="afeafcd5c4d1b332e1ff9260eee857145"></a><!-- doxytag: member="SimpleSprite::width" ref="afeafcd5c4d1b332e1ff9260eee857145" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_sprite_root.html#afeafcd5c4d1b332e1ff9260eee857145">SpriteRoot.width</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Width of the sprite in world space. </p>

</div>
</div>
<a class="anchor" id="a2053a628b672c6b3140ebc2e92264b09"></a><!-- doxytag: member="SimpleSprite::winding" ref="a2053a628b672c6b3140ebc2e92264b09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a> <a class="el" href="class_sprite_root.html#a2053a628b672c6b3140ebc2e92264b09">SpriteRoot.winding</a> = WINDING_ORDER.CW<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The winding order of the sprite's polygons - determines the direction the sprite will "face". </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="ab801616440fd6b9500f05dd3565d16b8"></a><!-- doxytag: member="SimpleSprite::BottomRight" ref="ab801616440fd6b9500f05dd3565d16b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.BottomRight<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the position of the bottom-right vertex of the sprite after any clipping or trimming. </p>

</div>
</div>
<a class="anchor" id="a222c8253fa3ef1911732d0de73cefb49"></a><!-- doxytag: member="SimpleSprite::Clipped" ref="a222c8253fa3ef1911732d0de73cefb49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SpriteRoot.Clipped<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for whether the sprite is to be clipped by any already-specified clipping rect. </p>

<p>Reimplemented in <a class="el" href="class_u_i_progress_bar.html#a07882c6777cea2dd8561c29bdccbbf47">UIProgressBar</a>, <a class="el" href="class_u_i_slider.html#aa6f272ac6012881e6544ba8f313d9ea5">UISlider</a>, and <a class="el" href="class_u_i_text_field.html#ab355658963ab766c09173c5bca91a4b1">UITextField</a>.</p>

</div>
</div>
<a class="anchor" id="a214c7409b2047bd2d533872271a4dc46"></a><!-- doxytag: member="SimpleSprite::ClippingRect" ref="a214c7409b2047bd2d533872271a4dc46" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_rect3_d.html">Rect3D</a> SpriteRoot.ClippingRect<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The rect against which the sprite should be clipped. The sprite will be immediately clipped by this rect when set. When setting, the rect should be in world space. </p>

<p>Reimplemented in <a class="el" href="class_u_i_progress_bar.html#a651029ce108c52b8ff5c01a26bbfdfdd">UIProgressBar</a>, <a class="el" href="class_u_i_slider.html#a7388983ed56a8bca2064bbd670b93beb">UISlider</a>, and <a class="el" href="class_u_i_text_field.html#a01044148b9fb87d85fdf8853420547dc">UITextField</a>.</p>

</div>
</div>
<a class="anchor" id="ac5a83817fe0a7ccf7910331b2e4eb6aa"></a><!-- doxytag: member="SimpleSprite::Managed" ref="ac5a83817fe0a7ccf7910331b2e4eb6aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpriteRoot.Managed<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite to a managed or batched state. </p>

</div>
</div>
<a class="anchor" id="a120de0df612b60e3722b3ef8a759faa5"></a><!-- doxytag: member="SimpleSprite::TopLeft" ref="a120de0df612b60e3722b3ef8a759faa5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.TopLeft<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the position of the top-left vertex of the sprite after any clipping or trimming. </p>

</div>
</div>
<a class="anchor" id="af4326379f44bf2e7f8410fb71add0476"></a><!-- doxytag: member="SimpleSprite::UnclippedBottomRight" ref="af4326379f44bf2e7f8410fb71add0476" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.UnclippedBottomRight<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The bottom-right corner of the sprite when no clipping or trimming is applied. </p>

</div>
</div>
<a class="anchor" id="a50292aa01cd979d345893d6a81c6f39b"></a><!-- doxytag: member="SimpleSprite::UnclippedTopLeft" ref="a50292aa01cd979d345893d6a81c6f39b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.UnclippedTopLeft<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The top-left corner of the sprite when no clipping or trimming is applied. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SimpleSprite.cs</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Nov 30 20:44:26 2010 for EZ GUI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
