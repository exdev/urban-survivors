<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EZ GUI: SpriteManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="contents">
<h1>SpriteManager Class Reference</h1><!-- doxytag: class="SpriteManager" -->
<p>Allows multiple sprites to be combined into a single mesh. Sprites are transformed using bones which are linked to GameObjects.  
<a href="#_details">More...</a></p>

<p><a href="class_sprite_manager-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#ac4de1487edcf6cd1868365355bb9e891">PixelSpaceToUVSpace</a> (Vector2 xy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_manager.html#a7162b003b26d934dc608d50ac62c11b3" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()!  <a href="#ac4de1487edcf6cd1868365355bb9e891"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#a0d7594e1380df710647f4c273b56b87e">PixelSpaceToUVSpace</a> (int x, int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_manager.html#a7162b003b26d934dc608d50ac62c11b3" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()!  <a href="#a0d7594e1380df710647f4c273b56b87e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#a7162b003b26d934dc608d50ac62c11b3">PixelCoordToUVCoord</a> (Vector2 xy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_manager.html#ac4de1487edcf6cd1868365355bb9e891" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()!  <a href="#a7162b003b26d934dc608d50ac62c11b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#af16780c4f6aaed18d6abee8c00337184">PixelCoordToUVCoord</a> (int x, int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_manager.html#ac4de1487edcf6cd1868365355bb9e891" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()!  <a href="#af16780c4f6aaed18d6abee8c00337184"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#a9c8ddf67e7e4bd8af5af897f021dc72f">AlreadyAdded</a> (<a class="el" href="class_sprite_root.html">SpriteRoot</a> sprite)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the sprite is already managed by this manager.  <a href="#a9c8ddf67e7e4bd8af5af897f021dc72f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SpriteMesh_Managed&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#a0766d51de0c87c6b45198f30e315b165">AddSprite</a> (GameObject go)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the sprite attached to the specified GameObject to the <a class="el" href="class_sprite_manager.html" title="Allows multiple sprites to be combined into a single mesh. Sprites are transformed...">SpriteManager</a>.  <a href="#a0766d51de0c87c6b45198f30e315b165"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SpriteMesh_Managed&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#adb45cb359d808357e5546a89de85bcc3">AddSprite</a> (<a class="el" href="class_sprite_root.html">SpriteRoot</a> sprite)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the specified sprite to the <a class="el" href="class_sprite_manager.html" title="Allows multiple sprites to be combined into a single mesh. Sprites are transformed...">SpriteManager</a>.  <a href="#adb45cb359d808357e5546a89de85bcc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#a46865b937e9ea15fd46f05ad52a6b9d4">CreateSprite</a> (GameObject prefab)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instantiates the specified prefab, which should contain a sprite, and immediately adds it to the manager.  <a href="#a46865b937e9ea15fd46f05ad52a6b9d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#ab5a5c0ecc570431c0f013a1af39b81d4">CreateSprite</a> (GameObject prefab, Vector3 position, Quaternion rotation)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instantiates the specified prefab, which should contain a sprite, and immediately adds it to the manager.  <a href="#ab5a5c0ecc570431c0f013a1af39b81d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#ab5b1e2488edca5743f0baae59df421b0">RemoveSprite</a> (<a class="el" href="class_sprite_root.html">SpriteRoot</a> sprite)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the specified sprite from the manager.  <a href="#ab5b1e2488edca5743f0baae59df421b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#aa47001a574922dff2d9709f98f583976">MoveToFront</a> (SpriteMesh_Managed s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the specified sprite to the end of the drawing order. (Causes it to appear in front of other sprites.).  <a href="#aa47001a574922dff2d9709f98f583976"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#af3eb1865068fa90e2e7a60eab4448f41">MoveToBack</a> (SpriteMesh_Managed s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the specified sprite to the start of the drawing order. (Causes it to appear behind other sprites.).  <a href="#af3eb1865068fa90e2e7a60eab4448f41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#a72d31758426e4502c49f194cd290b464">MoveInfrontOf</a> (SpriteMesh_Managed toMove, SpriteMesh_Managed reference)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the first sprite in front of the second sprite by placing it later in the draw order. If the sprite is already in front of the reference sprite, nothing is changed.  <a href="#a72d31758426e4502c49f194cd290b464"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#acddae77df74fd66fd05796ddda411ad0">MoveBehind</a> (SpriteMesh_Managed toMove, SpriteMesh_Managed reference)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the first sprite behind the second sprite by placing it earlier in the draw order. If the sprite is already behind, nothing is done.  <a href="#acddae77df74fd66fd05796ddda411ad0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#a2d5d067a16c1c52cabdf5dee0974b72a">UpdateBounds</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instructs the manager to recalculate the bounds of the mesh.  <a href="#a2d5d067a16c1c52cabdf5dee0974b72a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#ae4e4bc9f6bae6fd0ecf16a00a773702d">ScheduleBoundsUpdate</a> (float seconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedules a recalculation of the mesh bounds to occur at a regular interval (given in seconds).  <a href="#ae4e4bc9f6bae6fd0ecf16a00a773702d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#a80bae737107c10d4292e0241a157431f">CancelBoundsUpdate</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancels any previously scheduled bounds recalculations.  <a href="#a80bae737107c10d4292e0241a157431f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">SpriteRoot.WINDING_ORDER</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#aa7ac7f4003c80006649de7b29b790f53">winding</a> = SpriteRoot.WINDING_ORDER.CW</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether sprite polygons should be wound clock-wise or counter clock-wise. Determines which side of the sprite is considered by the renderer to be the "front".  <a href="#aa7ac7f4003c80006649de7b29b790f53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#aa33109f1236002a0a70ffc9df25d589e">allocBlockSize</a> = 10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">How many sprites to allocate at a time if the sprite pool is used up. This is also the starting pool size.  <a href="#aa33109f1236002a0a70ffc9df25d589e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#aaa516c78c2a9519713329943009ebae6">autoUpdateBounds</a> = true</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When true, will automatically recalculate the bounding box for the mesh whenever sprite vertices change. If the bounding box is never recalculated, when the camera moves, Unity may think the mesh is out of sight and cull it, even though it is not.  <a href="#aaa516c78c2a9519713329943009ebae6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_manager.html#a2cac0453a9bd1b41bc8a2e9dffe72df6">persistent</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If true, the <a class="el" href="class_sprite_manager.html" title="Allows multiple sprites to be combined into a single mesh. Sprites are transformed...">SpriteManager</a> object and associated mesh will survive a level load.  <a href="#a2cac0453a9bd1b41bc8a2e9dffe72df6"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Allows multiple sprites to be combined into a single mesh. Sprites are transformed using bones which are linked to GameObjects. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adb45cb359d808357e5546a89de85bcc3"></a><!-- doxytag: member="SpriteManager::AddSprite" ref="adb45cb359d808357e5546a89de85bcc3" args="(SpriteRoot sprite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SpriteMesh_Managed SpriteManager.AddSprite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>sprite</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the specified sprite to the <a class="el" href="class_sprite_manager.html" title="Allows multiple sprites to be combined into a single mesh. Sprites are transformed...">SpriteManager</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>go</em>&nbsp;</td><td>Reference to the desired sprite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the sprite's managed mesh.</dd></dl>

</div>
</div>
<a class="anchor" id="a0766d51de0c87c6b45198f30e315b165"></a><!-- doxytag: member="SpriteManager::AddSprite" ref="a0766d51de0c87c6b45198f30e315b165" args="(GameObject go)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SpriteMesh_Managed SpriteManager.AddSprite </td>
          <td>(</td>
          <td class="paramtype">GameObject&nbsp;</td>
          <td class="paramname"> <em>go</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the sprite attached to the specified GameObject to the <a class="el" href="class_sprite_manager.html" title="Allows multiple sprites to be combined into a single mesh. Sprites are transformed...">SpriteManager</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>go</em>&nbsp;</td><td>GameObject containing a sprite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the sprite's managed mesh.</dd></dl>

</div>
</div>
<a class="anchor" id="a9c8ddf67e7e4bd8af5af897f021dc72f"></a><!-- doxytag: member="SpriteManager::AlreadyAdded" ref="a9c8ddf67e7e4bd8af5af897f021dc72f" args="(SpriteRoot sprite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpriteManager.AlreadyAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>sprite</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the sprite is already managed by this manager. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite</em>&nbsp;</td><td>Sprite for which to look.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True when the sprite is already being managed by this manager.</dd></dl>

</div>
</div>
<a class="anchor" id="a80bae737107c10d4292e0241a157431f"></a><!-- doxytag: member="SpriteManager::CancelBoundsUpdate" ref="a80bae737107c10d4292e0241a157431f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteManager.CancelBoundsUpdate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancels any previously scheduled bounds recalculations. </p>

</div>
</div>
<a class="anchor" id="ab5a5c0ecc570431c0f013a1af39b81d4"></a><!-- doxytag: member="SpriteManager::CreateSprite" ref="ab5a5c0ecc570431c0f013a1af39b81d4" args="(GameObject prefab, Vector3 position, Quaternion rotation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html">SpriteRoot</a> SpriteManager.CreateSprite </td>
          <td>(</td>
          <td class="paramtype">GameObject&nbsp;</td>
          <td class="paramname"> <em>prefab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Quaternion&nbsp;</td>
          <td class="paramname"> <em>rotation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiates the specified prefab, which should contain a sprite, and immediately adds it to the manager. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prefab</em>&nbsp;</td><td>Prefab to be instantiated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Where to place the new sprite.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotation</em>&nbsp;</td><td>Rotation of the new sprite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to the sprite contained in the prafab.</dd></dl>

</div>
</div>
<a class="anchor" id="a46865b937e9ea15fd46f05ad52a6b9d4"></a><!-- doxytag: member="SpriteManager::CreateSprite" ref="a46865b937e9ea15fd46f05ad52a6b9d4" args="(GameObject prefab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html">SpriteRoot</a> SpriteManager.CreateSprite </td>
          <td>(</td>
          <td class="paramtype">GameObject&nbsp;</td>
          <td class="paramname"> <em>prefab</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiates the specified prefab, which should contain a sprite, and immediately adds it to the manager. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prefab</em>&nbsp;</td><td>Prefab to be instantiated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to the sprite contained in the prafab.</dd></dl>

</div>
</div>
<a class="anchor" id="acddae77df74fd66fd05796ddda411ad0"></a><!-- doxytag: member="SpriteManager::MoveBehind" ref="acddae77df74fd66fd05796ddda411ad0" args="(SpriteMesh_Managed toMove, SpriteMesh_Managed reference)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteManager.MoveBehind </td>
          <td>(</td>
          <td class="paramtype">SpriteMesh_Managed&nbsp;</td>
          <td class="paramname"> <em>toMove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpriteMesh_Managed&nbsp;</td>
          <td class="paramname"> <em>reference</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the first sprite behind the second sprite by placing it earlier in the draw order. If the sprite is already behind, nothing is done. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>toMove</em>&nbsp;</td><td>Sprite to move behind the reference sprite.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reference</em>&nbsp;</td><td>Sprite behind which "toMove" will be drawn.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72d31758426e4502c49f194cd290b464"></a><!-- doxytag: member="SpriteManager::MoveInfrontOf" ref="a72d31758426e4502c49f194cd290b464" args="(SpriteMesh_Managed toMove, SpriteMesh_Managed reference)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteManager.MoveInfrontOf </td>
          <td>(</td>
          <td class="paramtype">SpriteMesh_Managed&nbsp;</td>
          <td class="paramname"> <em>toMove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpriteMesh_Managed&nbsp;</td>
          <td class="paramname"> <em>reference</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the first sprite in front of the second sprite by placing it later in the draw order. If the sprite is already in front of the reference sprite, nothing is changed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>toMove</em>&nbsp;</td><td>Sprite to move in front of the reference sprite.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reference</em>&nbsp;</td><td>Sprite in front of which "toMove" will be drawn.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3eb1865068fa90e2e7a60eab4448f41"></a><!-- doxytag: member="SpriteManager::MoveToBack" ref="af3eb1865068fa90e2e7a60eab4448f41" args="(SpriteMesh_Managed s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteManager.MoveToBack </td>
          <td>(</td>
          <td class="paramtype">SpriteMesh_Managed&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the specified sprite to the start of the drawing order. (Causes it to appear behind other sprites.). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Sprite to move to the start of the drawing order.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa47001a574922dff2d9709f98f583976"></a><!-- doxytag: member="SpriteManager::MoveToFront" ref="aa47001a574922dff2d9709f98f583976" args="(SpriteMesh_Managed s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteManager.MoveToFront </td>
          <td>(</td>
          <td class="paramtype">SpriteMesh_Managed&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the specified sprite to the end of the drawing order. (Causes it to appear in front of other sprites.). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Sprite to move to the end of the drawing order.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af16780c4f6aaed18d6abee8c00337184"></a><!-- doxytag: member="SpriteManager::PixelCoordToUVCoord" ref="af16780c4f6aaed18d6abee8c00337184" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteManager.PixelCoordToUVCoord </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_manager.html#ac4de1487edcf6cd1868365355bb9e891" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The x-coordinate to convert.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The y-coordinate to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The coordinates converted to UV coordinates.</dd></dl>

</div>
</div>
<a class="anchor" id="a7162b003b26d934dc608d50ac62c11b3"></a><!-- doxytag: member="SpriteManager::PixelCoordToUVCoord" ref="a7162b003b26d934dc608d50ac62c11b3" args="(Vector2 xy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteManager.PixelCoordToUVCoord </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>xy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_manager.html#ac4de1487edcf6cd1868365355bb9e891" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xy</em>&nbsp;</td><td>The coordinates to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The coordinates converted to UV coordinates.</dd></dl>

</div>
</div>
<a class="anchor" id="a0d7594e1380df710647f4c273b56b87e"></a><!-- doxytag: member="SpriteManager::PixelSpaceToUVSpace" ref="a0d7594e1380df710647f4c273b56b87e" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteManager.PixelSpaceToUVSpace </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_manager.html#a7162b003b26d934dc608d50ac62c11b3" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X-value to convert.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y-value to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The values converted to UV space.</dd></dl>

</div>
</div>
<a class="anchor" id="ac4de1487edcf6cd1868365355bb9e891"></a><!-- doxytag: member="SpriteManager::PixelSpaceToUVSpace" ref="ac4de1487edcf6cd1868365355bb9e891" args="(Vector2 xy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteManager.PixelSpaceToUVSpace </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>xy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_manager.html#a7162b003b26d934dc608d50ac62c11b3" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xy</em>&nbsp;</td><td>The values to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The values converted to UV space.</dd></dl>

</div>
</div>
<a class="anchor" id="ab5b1e2488edca5743f0baae59df421b0"></a><!-- doxytag: member="SpriteManager::RemoveSprite" ref="ab5b1e2488edca5743f0baae59df421b0" args="(SpriteRoot sprite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteManager.RemoveSprite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>sprite</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the specified sprite from the manager. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite</em>&nbsp;</td><td>Sprite to remove from the manager.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4e4bc9f6bae6fd0ecf16a00a773702d"></a><!-- doxytag: member="SpriteManager::ScheduleBoundsUpdate" ref="ae4e4bc9f6bae6fd0ecf16a00a773702d" args="(float seconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteManager.ScheduleBoundsUpdate </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>seconds</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedules a recalculation of the mesh bounds to occur at a regular interval (given in seconds). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>seconds</em>&nbsp;</td><td>Time, in seconds, between bounds updates.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d5d067a16c1c52cabdf5dee0974b72a"></a><!-- doxytag: member="SpriteManager::UpdateBounds" ref="a2d5d067a16c1c52cabdf5dee0974b72a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteManager.UpdateBounds </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instructs the manager to recalculate the bounds of the mesh. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aa33109f1236002a0a70ffc9df25d589e"></a><!-- doxytag: member="SpriteManager::allocBlockSize" ref="aa33109f1236002a0a70ffc9df25d589e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_sprite_manager.html#aa33109f1236002a0a70ffc9df25d589e">SpriteManager.allocBlockSize</a> = 10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>How many sprites to allocate at a time if the sprite pool is used up. This is also the starting pool size. </p>

</div>
</div>
<a class="anchor" id="aaa516c78c2a9519713329943009ebae6"></a><!-- doxytag: member="SpriteManager::autoUpdateBounds" ref="aaa516c78c2a9519713329943009ebae6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_manager.html#aaa516c78c2a9519713329943009ebae6">SpriteManager.autoUpdateBounds</a> = true</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When true, will automatically recalculate the bounding box for the mesh whenever sprite vertices change. If the bounding box is never recalculated, when the camera moves, Unity may think the mesh is out of sight and cull it, even though it is not. </p>

</div>
</div>
<a class="anchor" id="a2cac0453a9bd1b41bc8a2e9dffe72df6"></a><!-- doxytag: member="SpriteManager::persistent" ref="a2cac0453a9bd1b41bc8a2e9dffe72df6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_manager.html#a2cac0453a9bd1b41bc8a2e9dffe72df6">SpriteManager.persistent</a> = false</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If true, the <a class="el" href="class_sprite_manager.html" title="Allows multiple sprites to be combined into a single mesh. Sprites are transformed...">SpriteManager</a> object and associated mesh will survive a level load. </p>

</div>
</div>
<a class="anchor" id="aa7ac7f4003c80006649de7b29b790f53"></a><!-- doxytag: member="SpriteManager::winding" ref="aa7ac7f4003c80006649de7b29b790f53" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">SpriteRoot.WINDING_ORDER</a> <a class="el" href="class_sprite_manager.html#aa7ac7f4003c80006649de7b29b790f53">SpriteManager.winding</a> = SpriteRoot.WINDING_ORDER.CW</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether sprite polygons should be wound clock-wise or counter clock-wise. Determines which side of the sprite is considered by the renderer to be the "front". </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SpriteManager.cs</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Feb 1 18:27:09 2011 for EZ GUI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
