<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EZ GUI: UIProgressBar Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="contents">
<h1>UIProgressBar Class Reference</h1><!-- doxytag: class="UIProgressBar" --><!-- doxytag: inherits="AutoSpriteControlBase" -->
<p>Inherits AutoSpriteControlBase.</p>

<p><a href="class_u_i_progress_bar-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">HORIZONTAL_ALIGN</a> { <a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">NONE</a>, 
<a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">LEFT</a>, 
<a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">RIGHT</a>, 
<a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">CENTER</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Specifies what the object will be aligned relative to on the horizontal axis. </p>
 <a href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">VERTICAL_ALIGN</a> { <a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">NONE</a>, 
<a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">TOP</a>, 
<a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">BOTTOM</a>, 
<a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">CENTER</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Specifies what the object will be aligned relative to on the vertical axis. </p>
 <a href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_i_progress_bar.html#a5565c5215ef4ca5d0fe99c1114f96d08">Copy</a> (<a class="el" href="class_sprite_root.html">SpriteRoot</a> s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies all the attributes of another sprite.  <a href="#a5565c5215ef4ca5d0fe99c1114f96d08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_i_progress_bar.html#a9d9a88cd142782d55a77c8dc0b8bc77b">Unclip</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes any clipping that is being applied to the sprite.  <a href="#a9d9a88cd142782d55a77c8dc0b8bc77b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_i_progress_bar.html#aede74d26180959c308452744d7bb29e9">Hide</a> (bool tf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hides or displays the sprite by disabling/enabling the sprite's mesh renderer component, or if managed, sets the mesh size to 0.  <a href="#aede74d26180959c308452744d7bb29e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_i_progress_bar.html#aa22b93ae30aac03c4c13eef2b197a78c">SetColor</a> (Color c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's color to the specified color.  <a href="#aa22b93ae30aac03c4c13eef2b197a78c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#affa83a7ae3fce4f0137273a59e29ccc6">Copy</a> (<a class="el" href="class_sprite_root.html">SpriteRoot</a> s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies all the vital attributes of another sprite.  <a href="#affa83a7ae3fce4f0137273a59e29ccc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_control.html#a6d4ed9fb745a353a176e1222dc689de3">Copy</a> (IControl c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the the specified control.  <a href="#a6d4ed9fb745a353a176e1222dc689de3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_control.html#a23fa6274e3a2cfd64acbb31b336fa208">Copy</a> (IControl c, ControlCopyFlags flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the specified parts of the specified control.  <a href="#a23fa6274e3a2cfd64acbb31b336fa208"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#a0fb97744935800a9d471d38d2520e855">UpdateCollider</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Updates the collider of the control so that it encompasses the extents of the control's content. NOTE: To include the control's associated text in the calculation, be sure to check the includeTextInAutoCollider box.  <a href="#a0fb97744935800a9d471d38d2520e855"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#a0e8dd93bcc6d71d85ae304d48f534691">GetStateLabel</a> (int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets/sets the array of strings that correspond to each control state.  <a href="#a0e8dd93bcc6d71d85ae304d48f534691"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#a4be330b4be1cb38e1eee340b6cc312e5">SetStateLabel</a> (int index, string label)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the string for the specified state label.  <a href="#a4be330b4be1cb38e1eee340b6cc312e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a1e221c6a3483a077d381b276ede895d0">Clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets important sprite values to defaults for reuse.  <a href="#a1e221c6a3483a077d381b276ede895d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a42253e9abd7dd0b294c6e4bbc8acd3d7">Setup</a> (float w, float h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the essential elements of a sprite.  <a href="#a42253e9abd7dd0b294c6e4bbc8acd3d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#ac975a3763bd5f83a38c5934a5f2d7ab2">Setup</a> (float w, float h, Material material)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets up the essential elements of a sprite.  <a href="#ac975a3763bd5f83a38c5934a5f2d7ab2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a714ac32248117514d8b6f7a27551ef72">CopyAll</a> (<a class="el" href="class_sprite_root.html">SpriteRoot</a> s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies all the attributes of another sprite, including its edit-time TextureAnimations.  <a href="#a714ac32248117514d8b6f7a27551ef72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d">PlayAnim</a> (<a class="el" href="class_u_v_animation.html">UVAnimation</a> anim, int frame)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>.  <a href="#ac5f3e9d674ab41aa1e069ec01517992d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a438d2824e04660d82a77abc839ffb845">PlayAnim</a> (<a class="el" href="class_u_v_animation.html">UVAnimation</a> anim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>.  <a href="#a438d2824e04660d82a77abc839ffb845"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#ab46b9872a258096efef96864d42e8e9f">PlayAnim</a> (int index, int frame)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>.  <a href="#ab46b9872a258096efef96864d42e8e9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#acdaf95fd4a39f650b5e856cfaab52500">PlayAnim</a> (int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>.  <a href="#acdaf95fd4a39f650b5e856cfaab52500"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a3a4a62fb2cb35e1bc56a8431fd9b546b">PlayAnim</a> (string name, int frame)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>.  <a href="#a3a4a62fb2cb35e1bc56a8431fd9b546b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#ad1fe80cecaf01875aa37cc2cefeee2df">PlayAnim</a> (string name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>.  <a href="#ad1fe80cecaf01875aa37cc2cefeee2df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#ab3f9440921b92de0bcfff9b3f873f4a9">PlayAnimInReverse</a> (<a class="el" href="class_u_v_animation.html">UVAnimation</a> anim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>.  <a href="#ab3f9440921b92de0bcfff9b3f873f4a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a7b68631bf06ebefe6f27ade8db16274d">PlayAnimInReverse</a> (<a class="el" href="class_u_v_animation.html">UVAnimation</a> anim, int frame)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>.  <a href="#a7b68631bf06ebefe6f27ade8db16274d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#afb5971eab818510cfc5560a5a2c25073">PlayAnimInReverse</a> (int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>.  <a href="#afb5971eab818510cfc5560a5a2c25073"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a9d701fbeeba36c4d9fe26a22f83b931a">PlayAnimInReverse</a> (int index, int frame)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>.  <a href="#a9d701fbeeba36c4d9fe26a22f83b931a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a1ae3268e68a5130cc67074041ca97d1c">PlayAnimInReverse</a> (string name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>.  <a href="#a1ae3268e68a5130cc67074041ca97d1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#ad384def788209def1799cb0480dd0da4">PlayAnimInReverse</a> (string name, int frame)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>.  <a href="#ad384def788209def1799cb0480dd0da4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#ad441cd232a70b064def9e906284aba0a">DoAnim</a> (int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plays the specified animation only if it is not already playing.  <a href="#ad441cd232a70b064def9e906284aba0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#af6719f34a9728652829e1046d366c4be">DoAnim</a> (string name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plays the specified animation only if it is not already playing.  <a href="#af6719f34a9728652829e1046d366c4be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a4be4f7e5323edbe6890363afa6686638">DoAnim</a> (<a class="el" href="class_u_v_animation.html">UVAnimation</a> anim)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plays the specified animation only if it is not already playing.  <a href="#a4be4f7e5323edbe6890363afa6686638"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a58d86446fef1c870cd7eb43ce7f0d1b0">SetCurFrame</a> (int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current frame of the current animation immediately.  <a href="#a58d86446fef1c870cd7eb43ce7f0d1b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#ad169d4a6bc4aaa2d90bf99b0fc887f23">StopAnim</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops the current animation from playing and resets it to the beginning for playing again. The sprite then reverts to the static image.  <a href="#ad169d4a6bc4aaa2d90bf99b0fc887f23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84">UnpauseAnim</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resumes an animation from where it left off previously.  <a href="#a82842d7d4dc6bdeb296e838221658e84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_u_v_animation.html">UVAnimation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#ad76fb600b3e93043fa4110b9da87c73e">GetCurAnim</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to the currently selected animation. NOTE: This does not mean the animation is currently playing. To determine whether the animation is playing, use <a class="el" href="class_sprite_base.html#ac98a457ace0eee0fecf82c8e089cc1a5" title="Returns whether the sprite is currently animating.">IsAnimating</a>.  <a href="#ad76fb600b3e93043fa4110b9da87c73e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_u_v_animation.html">UVAnimation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a2f77566caf369e7e14541c763c00a565">GetAnim</a> (string name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to the animation that matches the name specified.  <a href="#a2f77566caf369e7e14541c763c00a565"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#afb7965badcdaa58e6e4a0cbcb0ae8f5b">GetStateIndex</a> (string stateName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the state with the specified name. -1 if no state matching the specified name is found.  <a href="#afb7965badcdaa58e6e4a0cbcb0ae8f5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a1b86d05e9616ec6d21f0c7e6d486f081">SetState</a> (int index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite to the specified state/animation.  <a href="#a1b86d05e9616ec6d21f0c7e6d486f081"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#ae05f863c7be4bdd30515bb335472deb9">AnimCompleteDelegate</a> (<a class="el" href="class_sprite_base.html">SpriteBase</a> sprite)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#ab0458aed4b016766469c1670e5503950">AnimFrameDelegate</a> (<a class="el" href="class_sprite_base.html">SpriteBase</a> sprite, int frame)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a1f5ee0eb97ebc94d31fc1e31fcb12e68">Delete</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If non-managed, call <a class="el" href="class_sprite_base.html#a1f5ee0eb97ebc94d31fc1e31fcb12e68" title="If non-managed, call Delete() before destroying this component or the GameObject...">Delete()</a> before destroying this component or the GameObject to which it is attached. Memory leaks can ensue otherwise.  <a href="#a1f5ee0eb97ebc94d31fc1e31fcb12e68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a923fa607ba560c946de87c05e6da85c5">SetAnimCompleteDelegate</a> (AnimCompleteDelegate del)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the delegate to be called upon animation completion.  <a href="#a923fa607ba560c946de87c05e6da85c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#ad31805dac2d46592bc30a95eabf899cb">SetAnimFrameDelegate</a> (AnimFrameDelegate del)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the delegate to be called each frame of animation.  <a href="#ad31805dac2d46592bc30a95eabf899cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a8849952300de0c69e246cea541d30e3a">SetSpriteResizedDelegate</a> (SpriteResizedDelegate del)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the delegate to be called when the sprite is resized.  <a href="#a8849952300de0c69e246cea541d30e3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#acd1248c74ff3e79c75ba994512d6e117">AddSpriteResizedDelegate</a> (SpriteResizedDelegate del)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the delegate to be called when the sprite is resized.  <a href="#acd1248c74ff3e79c75ba994512d6e117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a10f2bcae2161110b2acd5e5b9cca3300">RemoveSpriteresizedDelegate</a> (SpriteResizedDelegate del)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the specified delegate from the list of those to be called when the sprite is resized.  <a href="#a10f2bcae2161110b2acd5e5b9cca3300"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a2ac2df7765bc1baeb3643948024b30a1">SetFramerate</a> (float fps)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes the framerate at which the current animation plays. NOTE: This only has effect if called AFTER PlayAnim() is called. Otherwise, PlayAnim() sets the framerate to whatever is specified in the animation itself.  <a href="#a2ac2df7765bc1baeb3643948024b30a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a88bdbcaa86cdd2e54908dae42dd79872">PauseAnim</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pauses the currently-playing animation.  <a href="#a88bdbcaa86cdd2e54908dae42dd79872"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a8b88afbf9c807629620803fc9e0fb982">RevertToStatic</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverts the sprite to its static (non-animating) default appearance.  <a href="#a8b88afbf9c807629620803fc9e0fb982"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#ac98a457ace0eee0fecf82c8e089cc1a5">IsAnimating</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the sprite is currently animating.  <a href="#ac98a457ace0eee0fecf82c8e089cc1a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">delegate void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a225681fbdb6d79c769c107293949f37f">SpriteResizedDelegate</a> (float newWidth, float newHeight, <a class="el" href="class_sprite_root.html">SpriteRoot</a> sprite)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a09d7f0014281fa0dcdd872c8ad4826a9">PositionOnScreen</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Repositions the object using the existing screen-space settings.  <a href="#a09d7f0014281fa0dcdd872c8ad4826a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a481a3e5c7d1b3370935564ca611fa9fe">PositionOnScreen</a> (int x, int y, float depth)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Positions the object using screen coordinates, according to the relativity settings stored in relativeToScreen.  <a href="#a481a3e5c7d1b3370935564ca611fa9fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#aabf07745fff23716a19e591a4d00ecb0">PositionOnScreen</a> (Vector3 pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Positions the object using screen coordinates, according to the relativity settings stored in relativeToScreen.  <a href="#aabf07745fff23716a19e591a4d00ecb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a3c11e0d03884e3af7b5040737f2064bd">CalcSize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recalculates the width and height of the sprite based upon the change in its UV dimensions (autoResize) or on the current camera's disposition (pixelPerfect).  <a href="#a3c11e0d03884e3af7b5040737f2064bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#adf9809122c570941ff132a9904dcc93c">SetSize</a> (float <a class="el" href="class_sprite_root.html#afeafcd5c4d1b332e1ff9260eee857145">width</a>, float <a class="el" href="class_sprite_root.html#a6bf98fa584df909a7864c4bccfda0b75">height</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the physical dimensions of the sprite in the plane selected.  <a href="#adf9809122c570941ff132a9904dcc93c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#aff78916688134aa447c8071fe552b209">UpdateUVs</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies any changes to the UVs to the actual sprite mesh.  <a href="#aff78916688134aa447c8071fe552b209"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#abc1b7cd60a2b90903fe4ea925f9c17d1">IsHidden</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the sprite is currently set to be hideAtStart (whether its mesh renderer component is enabled).  <a href="#abc1b7cd60a2b90903fe4ea925f9c17d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a26d2276f1705f7e61019cf621dd6d2b1">SetBleedCompensation</a> (float x, float y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>).  <a href="#a26d2276f1705f7e61019cf621dd6d2b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ab9108d36331abd7a6b629b3af7193a85">SetBleedCompensation</a> (Vector2 xy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>).  <a href="#ab9108d36331abd7a6b629b3af7193a85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#adce43163ad8ad0693c3ea7c109d8408b">SetPlane</a> (<a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a> p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the plane in which the sprite is to be drawn. See: <a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>.  <a href="#adce43163ad8ad0693c3ea7c109d8408b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a4c7f3a0e628f66c612bc80ff4a003021">SetWindingOrder</a> (<a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a> order)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the winding order to use. See <a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>.  <a href="#a4c7f3a0e628f66c612bc80ff4a003021"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a0352fc2f67d2258329f74dcc86bd4d56">SetDrawLayer</a> (int layer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the draw layer of the sprite (only applies to managed sprites).  <a href="#a0352fc2f67d2258329f74dcc86bd4d56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a355b24c10aa7ae976c21e944f3eb22f9">SetFrameInfo</a> (<a class="el" href="struct_s_p_r_i_t_e___f_r_a_m_e.html">SPRITE_FRAME</a> fInfo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's frame info, which includes UVs, offsets, etc.  <a href="#a355b24c10aa7ae976c21e944f3eb22f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ab7b38c49c508eb9300fa9116a3074ace">SetUVs</a> (Rect uv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's UVs to the specified values.  <a href="#ab7b38c49c508eb9300fa9116a3074ace"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a2099af0859ccd329e09ff83177811127">SetUVsFromPixelCoords</a> (Rect pxCoords)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite's UVs from pixel coordinates.  <a href="#a2099af0859ccd329e09ff83177811127"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Rect&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a8c337e11b78774a1cc4e2a47d3343c95">GetUVs</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current UV coordinates of the sprite (before bleed compensation).  <a href="#a8c337e11b78774a1cc4e2a47d3343c95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a778d47660b7a9a6695aa77ae24862434">GetVertices</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a reference to the sprite's vertices. NOTE: You can only directly modify the sprite's vertices if it is a non-managed sprite.  <a href="#a778d47660b7a9a6695aa77ae24862434"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a729b35193db1829b0732151d4de39d05">GetCenterPoint</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the center point of the sprite, taking into account the actual positions of vertices.  <a href="#a729b35193db1829b0732151d4de39d05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#af114f93fa3ad60b469e07346911a5cad">SetAnchor</a> (<a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a> a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the anchor method to use. See <a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>.  <a href="#af114f93fa3ad60b469e07346911a5cad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a6ae2f4d7bce23b55d8b9d273434623e7">SetOffset</a> (Vector3 o)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the offset of the sprite from its GameObject. See <a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457" title="Offsets the sprite, in world space, from the center of its GameObject.">offset</a>.  <a href="#a6ae2f4d7bce23b55d8b9d273434623e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e">PixelSpaceToUVSpace</a> (Vector2 xy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()!  <a href="#aa9db529bff27dfcdbb0e5e33ed0fbc2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a61151a87fd06071bd680ebad9946512e">PixelSpaceToUVSpace</a> (int x, int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()!  <a href="#a61151a87fd06071bd680ebad9946512e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975">PixelCoordToUVCoord</a> (Vector2 xy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()!  <a href="#ae3931a73d6842ec8a98d93b718004975"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a5ff8725f90b8609efe0f4fff819bac74">PixelCoordToUVCoord</a> (int x, int y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()!  <a href="#a5ff8725f90b8609efe0f4fff819bac74"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_u_i_progress_bar.html">UIProgressBar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_i_progress_bar.html#a17015a86cbcb12e1f323cc6f0eb6047d">Create</a> (string name, Vector3 pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a GameObject and attaches this component type to it.  <a href="#a17015a86cbcb12e1f323cc6f0eb6047d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_u_i_progress_bar.html">UIProgressBar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_i_progress_bar.html#a9386b761e4b3f1c5df98b7a9e5c37107">Create</a> (string name, Vector3 pos, Quaternion rotation)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a GameObject and attaches this component type to it.  <a href="#a9386b761e4b3f1c5df98b7a9e5c37107"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html">SpriteRoot</a>[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_i_progress_bar.html#aeb04f02675c7f90ecd576151e6f3e002">filledLayers</a> = new <a class="el" href="class_sprite_root.html">SpriteRoot</a>[0]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An array of references to sprites which will visually represent this control. Each element (layer) represents another layer to be drawn. This allows you to use multiple sprites to draw a single control, achieving a sort of layered effect. Ex: You can use a second layer to overlay a button with a highlight effect.  <a href="#aeb04f02675c7f90ecd576151e6f3e002"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#a35b772db0c95797e01440199546a375b">DittoString</a> = &quot;[\&quot;]&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">String whose meaning is to keep the previous state's label.  <a href="#a35b772db0c95797e01440199546a375b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#a83e8c577eb5b24421c3d9624c7047d8e">text</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Text to be displayed on the control. Do not set this directly in-code. Instead, use the "Text" property or else your changes will not take effect.  <a href="#a83e8c577eb5b24421c3d9624c7047d8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_text.html">SpriteText</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#ad22bb073415f6850ded5d0cf3079f4a4">spriteText</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference to optional <a class="el" href="class_sprite_text.html">SpriteText</a> which will display this item's text. It is STRONGLY recommended that this mesh exist on a GameObject that is a child of the list item itself.  <a href="#ad22bb073415f6850ded5d0cf3079f4a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#adfc2cf4856ccd7162604aa52f4c5e3fd">textOffsetZ</a> = -0.1f</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When text is generated by the control at runtime, it will, by default, have its offsetZ setting set to this value. NOTE: Negative values will result in text being in front of the control. Positive values will place the text behind the control.  <a href="#adfc2cf4856ccd7162604aa52f4c5e3fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#a202cda8687f106341921b2268955dbd4">includeTextInAutoCollider</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When true, of a collider is generated for the control, the associated text is taken into account when calculating the extents of the collider.  <a href="#a202cda8687f106341921b2268955dbd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">object&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#a5daea5d98746bfeddc7c0d2a26314fd2">data</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Can hold a reference to any data that the developer wishes to be associated with the control.  <a href="#a5daea5d98746bfeddc7c0d2a26314fd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_u_v_animation.html">UVAnimation</a>[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#a2a66708e5326f2385b68dad5f7a47afa">animations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds the actual UV sequences that will be used at run-time.  <a href="#a2a66708e5326f2385b68dad5f7a47afa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a9c2a037051bc8954928bc97f78c8748b">playAnimOnStart</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When set to true, the sprite will play the default animation (see <a class="el" href="class_sprite_base.html#a9d3a230326feff1dc46a065f50d4d5e8" title="Index of the animation to play by default.">defaultAnim</a>) when the sprite is instantiated.  <a href="#a9c2a037051bc8954928bc97f78c8748b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a9d3a230326feff1dc46a065f50d4d5e8">defaultAnim</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index of the animation to play by default.  <a href="#a9d3a230326feff1dc46a065f50d4d5e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a27b40cf9515a2d0cae6391fc974c8316">managed</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When true, the sprite will be managed by the selected sprite manager script. When false, the sprite has its own mesh and will be batched automatically with other sprites (when available - Unity iPhone).  <a href="#a27b40cf9515a2d0cae6391fc974c8316"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_manager.html">SpriteManager</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a2ce487455dd3b14e10cfa97a37b3da20">manager</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference to the manager which will manage this sprite, provided managed is set to true.  <a href="#a2ce487455dd3b14e10cfa97a37b3da20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a38effd07c9700447283d092a0981e411">drawLayer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The layer in which the sprite will be drawn if managed.  <a href="#a38effd07c9700447283d092a0981e411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a5be17e1b254ce8a2c0b2f16a0be9a3a3">persistent</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This must be set to true at design time for the sprite to survive loading a new level.  <a href="#a5be17e1b254ce8a2c0b2f16a0be9a3a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a821509586d7b454250d1c7c0b3dd4f74">plane</a> = SPRITE_PLANE.XY</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The plane in which the sprite will be drawn.  <a href="#a821509586d7b454250d1c7c0b3dd4f74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a2053a628b672c6b3140ebc2e92264b09">winding</a> = WINDING_ORDER.CW</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The winding order of the sprite's polygons - determines the direction the sprite will "face".  <a href="#a2053a628b672c6b3140ebc2e92264b09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#afeafcd5c4d1b332e1ff9260eee857145">width</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Width of the sprite in world space.  <a href="#afeafcd5c4d1b332e1ff9260eee857145"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a6bf98fa584df909a7864c4bccfda0b75">height</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Height of the sprite in world space.  <a href="#a6bf98fa584df909a7864c4bccfda0b75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f">bleedCompensation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Will contract the UV edges of the sprite by the specified amount to prevent "bleeding" from neighboring pixels, especially when mipmapping.  <a href="#a8a9de6bf34778b74f87b3d8e71c3342f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a3ea8ab87a750bfafc3cffc34b14f3eba">anchor</a> = ANCHOR_METHOD.TEXTURE_OFFSET</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Anchor method to use. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a></dd></dl>
<p>.  <a href="#a3ea8ab87a750bfafc3cffc34b14f3eba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ae3ebdc6d208c66fcc58fe9bdd1e993fe">pixelPerfect</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatically sizes the sprite so that it will display pixel-perfect on-screen. NOTE: If you change the orthographic size of the camera or the distance between the sprite and a perspective camera, call <a class="el" href="class_sprite_root.html#a4f2fdef32da501a717c69eef466d2135" title="Sets the camera to use when calculating a pixel-perfect sprite size.">SetCamera()</a> to make the text pixel-perfect again. However, if you want automatic resizing functionality without being pixel-perfect and therefore allowing zooming in and out, use <a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd" title="Automatically resizes the sprite based on its new UV dimensions compared to its previous...">autoResize</a> instead.  <a href="#ae3ebdc6d208c66fcc58fe9bdd1e993fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd">autoResize</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatically resizes the sprite based on its new UV dimensions compared to its previous dimensions. Setting this to true allows you to use non-uniform sized sprites for animation without causing the sprite to appear "squashed" while animating.  <a href="#ad6bda2f46906d69166ee4b931c3108dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457">offset</a> = new Vector3()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Offsets the sprite, in world space, from the center of its GameObject.  <a href="#a437424afa712a3ae537768cc0e3a2457"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Color&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a206a1db950fc52aaef5b535a7b1a938a">color</a> = Color.white</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The color to be used by all four of the sprite's vertices. This can be used to color, highlight, or fade the sprite. Be sure to use a vertex-colored shader for this to have an effect.  <a href="#a206a1db950fc52aaef5b535a7b1a938a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a9905374808829c2c6a15ffeb0170bf52">hideAtStart</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the sprite will be hideAtStart when it starts.  <a href="#a9905374808829c2c6a15ffeb0170bf52"></a><br/></td></tr>
<tr><td colspan="2"><h2>Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_i_progress_bar.html#a7902274c1259bc2440a8d41865760d3f">Value</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents the percent of progress. Valid range is from 0-1.  <a href="#a7902274c1259bc2440a8d41865760d3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override <a class="el" href="class_texture_anim.html">TextureAnim</a>[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_i_progress_bar.html#a9dd6488baab44307e2a674c2f2d68089">States</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for the sprite's various states as defined in the editor (not used at runtime).  <a href="#a9dd6488baab44307e2a674c2f2d68089"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_i_progress_bar.html#a07882c6777cea2dd8561c29bdccbbf47">Clipped</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for whether the sprite is to be clipped by any already-specified clipping rect.  <a href="#a07882c6777cea2dd8561c29bdccbbf47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">override <a class="el" href="struct_rect3_d.html">Rect3D</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_i_progress_bar.html#a651029ce108c52b8ff5c01a26bbfdfdd">ClippingRect</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rect against which the sprite should be clipped. The sprite will be immediately clipped by this rect when set. When setting, the rect should be in world space.  <a href="#a651029ce108c52b8ff5c01a26bbfdfdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#a77cfaeeba1f4bd9a432c79143ee49d39">Text</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the text to be displayed in this control.  <a href="#a77cfaeeba1f4bd9a432c79143ee49d39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">object&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#ab38a2f9f8457e89b4aa1e1a29fc35d8d">Data</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor for the data member to comply with the IControl interface.  <a href="#ab38a2f9f8457e89b4aa1e1a29fc35d8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#a4336876830973caa05ff90ddb8c2764c">TopLeftEdge</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The top-left edge of the control, when no clipping or trimming is applied, and includes all layers and text.  <a href="#a4336876830973caa05ff90ddb8c2764c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#a9d4b97c1b26ca5a4c89fe9e07192a84d">BottomRightEdge</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bottom-right edge of the control, when no clipping or trimming is applied, and includes all layers and text.  <a href="#a9d4b97c1b26ca5a4c89fe9e07192a84d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_control_base.html#a633c03fb5361d8a2a632f1ead061ebbc">controlIsEnabled</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows you to get/set whether the control is disabled. If it is disabled, it will not receive input.  <a href="#a633c03fb5361d8a2a632f1ead061ebbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_c_sprite_frame.html">CSpriteFrame</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_auto_sprite_base.html#aacea1f4b75640daba8dcd448d2634122">DefaultFrame</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the default frame of the sprite object. This is the appearance the sprite is to have in the editor.  <a href="#aacea1f4b75640daba8dcd448d2634122"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#ae427641cebb3e76e7a2cb2ffdf445836">Animating</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Property useful for use with EZ Game Saver. When it gets set, the current animation is started. Include this, along with CurAnimIndex, as a saved property so that any playing animation is resumed.  <a href="#ae427641cebb3e76e7a2cb2ffdf445836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_base.html#a88bfefa27afedef3c2ab1883fdb2a364">CurAnimIndex</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Property useful for use with EZ Game Saver. Include this as a saved property, along with Animating, so that any playing animation is resumed.  <a href="#a88bfefa27afedef3c2ab1883fdb2a364"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ac5a83817fe0a7ccf7910331b2e4eb6aa">Managed</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the sprite to a managed or batched state.  <a href="#ac5a83817fe0a7ccf7910331b2e4eb6aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a50292aa01cd979d345893d6a81c6f39b">UnclippedTopLeft</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The top-left corner of the sprite when no clipping or trimming is applied.  <a href="#a50292aa01cd979d345893d6a81c6f39b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#af4326379f44bf2e7f8410fb71add0476">UnclippedBottomRight</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The bottom-right corner of the sprite when no clipping or trimming is applied.  <a href="#af4326379f44bf2e7f8410fb71add0476"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#a120de0df612b60e3722b3ef8a759faa5">TopLeft</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the position of the top-left vertex of the sprite after any clipping or trimming.  <a href="#a120de0df612b60e3722b3ef8a759faa5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sprite_root.html#ab801616440fd6b9500f05dd3565d16b8">BottomRight</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the position of the bottom-right vertex of the sprite after any clipping or trimming.  <a href="#ab801616440fd6b9500f05dd3565d16b8"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A progress bar class. Progress is altered by changing the "Value" property (valid values are from 0-1). </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a79b7138073d866284a170e4d8b3a9217"></a><!-- doxytag: member="UIProgressBar::ANCHOR_METHOD" ref="a79b7138073d866284a170e4d8b3a9217" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">SpriteRoot::ANCHOR_METHOD</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The anchoring scheme of a sprite. The anchor point is the point on the sprite that will remain stationary when the sprite's size changes. For a health bar that "grows" to the right while its left edge remains stationary, you would use UPPER_LEFT, MIDDLE_LEFT, or BOTTOM_LEFT.</p>
<p>For a health bar that "grows" upward while the bottom edge remains stationary, you would use BOTTOM_LEFT, BOTTOM_CENTER, or BOTTOM_RIGHT.</p>

</div>
</div>
<a class="anchor" id="ad31e772b9c659d24c829386c63f50566"></a><!-- doxytag: member="UIProgressBar::HORIZONTAL_ALIGN" ref="ad31e772b9c659d24c829386c63f50566" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#ad31e772b9c659d24c829386c63f50566">SpriteRoot::HORIZONTAL_ALIGN</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies what the object will be aligned relative to on the horizontal axis. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad31e772b9c659d24c829386c63f50566"></a><!-- doxytag: member="NONE" ref="ad31e772b9c659d24c829386c63f50566" args="" -->NONE</em>&nbsp;</td><td>
<p>The object will not be repositioned along the X axis. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad31e772b9c659d24c829386c63f50566"></a><!-- doxytag: member="LEFT" ref="ad31e772b9c659d24c829386c63f50566" args="" -->LEFT</em>&nbsp;</td><td>
<p>The X coordinate of screenPos will be interpreted as the number of pixels from the left edge of the screen. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad31e772b9c659d24c829386c63f50566"></a><!-- doxytag: member="RIGHT" ref="ad31e772b9c659d24c829386c63f50566" args="" -->RIGHT</em>&nbsp;</td><td>
<p>The X coordinate of screenPos will be interpreted as the number of pixels from the right edge of the screen. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad31e772b9c659d24c829386c63f50566"></a><!-- doxytag: member="CENTER" ref="ad31e772b9c659d24c829386c63f50566" args="" -->CENTER</em>&nbsp;</td><td>
<p>The X coordinate of screenPos will be interpreted as the number of pixels from the center of the screen. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f354b80a58bab8f31f7966750800e57"></a><!-- doxytag: member="UIProgressBar::SPRITE_PLANE" ref="a4f354b80a58bab8f31f7966750800e57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SpriteRoot::SPRITE_PLANE</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The plane in which a sprite should be drawn. </p>

</div>
</div>
<a class="anchor" id="af7a4d8ff195106468232a3e5a7d32c78"></a><!-- doxytag: member="UIProgressBar::VERTICAL_ALIGN" ref="af7a4d8ff195106468232a3e5a7d32c78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#af7a4d8ff195106468232a3e5a7d32c78">SpriteRoot::VERTICAL_ALIGN</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies what the object will be aligned relative to on the vertical axis. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af7a4d8ff195106468232a3e5a7d32c78"></a><!-- doxytag: member="NONE" ref="af7a4d8ff195106468232a3e5a7d32c78" args="" -->NONE</em>&nbsp;</td><td>
<p>The object will not be repositioned along the Y axis. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af7a4d8ff195106468232a3e5a7d32c78"></a><!-- doxytag: member="TOP" ref="af7a4d8ff195106468232a3e5a7d32c78" args="" -->TOP</em>&nbsp;</td><td>
<p>The Y coordinate of screenPos will be interpreted as the number of pixels from the top edge of the screen. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af7a4d8ff195106468232a3e5a7d32c78"></a><!-- doxytag: member="BOTTOM" ref="af7a4d8ff195106468232a3e5a7d32c78" args="" -->BOTTOM</em>&nbsp;</td><td>
<p>The Y coordinate of screenPos will be interpreted as the number of pixels from the bottom edge of the screen. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af7a4d8ff195106468232a3e5a7d32c78"></a><!-- doxytag: member="CENTER" ref="af7a4d8ff195106468232a3e5a7d32c78" args="" -->CENTER</em>&nbsp;</td><td>
<p>The Y coordinate of screenPos will be interpreted as the number of pixels from the center of the screen. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6a06ad89a880accb25794e862733074"></a><!-- doxytag: member="UIProgressBar::WINDING_ORDER" ref="aa6a06ad89a880accb25794e862733074" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">SpriteRoot::WINDING_ORDER</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines which way the polygons of a sprite should be wound. The two options are clock-wise (CW) and counter clock-wise (CCW). These determine the direction the sprite will "face". </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acd1248c74ff3e79c75ba994512d6e117"></a><!-- doxytag: member="UIProgressBar::AddSpriteResizedDelegate" ref="acd1248c74ff3e79c75ba994512d6e117" args="(SpriteResizedDelegate del)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.AddSpriteResizedDelegate </td>
          <td>(</td>
          <td class="paramtype">SpriteResizedDelegate&nbsp;</td>
          <td class="paramname"> <em>del</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the delegate to be called when the sprite is resized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>del</em>&nbsp;</td><td>A delegate to be called when the sprite is resized.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae05f863c7be4bdd30515bb335472deb9"></a><!-- doxytag: member="UIProgressBar::AnimCompleteDelegate" ref="ae05f863c7be4bdd30515bb335472deb9" args="(SpriteBase sprite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate void SpriteBase.AnimCompleteDelegate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_base.html">SpriteBase</a>&nbsp;</td>
          <td class="paramname"> <em>sprite</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines a delegate that can be called upon animation completion. Use this if you want something to happen as soon as an animation reaches the end. Receives a reference to the sprite.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite</em>&nbsp;</td><td>A reference to the sprite whose animation has finished.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0458aed4b016766469c1670e5503950"></a><!-- doxytag: member="UIProgressBar::AnimFrameDelegate" ref="ab0458aed4b016766469c1670e5503950" args="(SpriteBase sprite, int frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate void SpriteBase.AnimFrameDelegate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_base.html">SpriteBase</a>&nbsp;</td>
          <td class="paramname"> <em>sprite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines a delegate that can be called once for each frame of animation. Use this if you want something to happen on an animation frame. Receives a reference to the sprite and the zero-based index of the current frame as an argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sprite</em>&nbsp;</td><td>A reference to the sprite which is calling the delegate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame</em>&nbsp;</td><td>The current animation frame number. (0-based)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c11e0d03884e3af7b5040737f2064bd"></a><!-- doxytag: member="UIProgressBar::CalcSize" ref="a3c11e0d03884e3af7b5040737f2064bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.CalcSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculates the width and height of the sprite based upon the change in its UV dimensions (autoResize) or on the current camera's disposition (pixelPerfect). </p>

</div>
</div>
<a class="anchor" id="a1e221c6a3483a077d381b276ede895d0"></a><!-- doxytag: member="UIProgressBar::Clear" ref="a1e221c6a3483a077d381b276ede895d0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void AutoSpriteBase.Clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets important sprite values to defaults for reuse. </p>

<p>Reimplemented from <a class="el" href="class_sprite_base.html#a1645f45e87839994a623d8a70135b000">SpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="a23fa6274e3a2cfd64acbb31b336fa208"></a><!-- doxytag: member="UIProgressBar::Copy" ref="a23fa6274e3a2cfd64acbb31b336fa208" args="(IControl c, ControlCopyFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IControl.Copy </td>
          <td>(</td>
          <td class="paramtype">IControl&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ControlCopyFlags&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the specified parts of the specified control. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The control to be copied.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying which attributes of the control are to be copied.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d4ed9fb745a353a176e1222dc689de3"></a><!-- doxytag: member="UIProgressBar::Copy" ref="a6d4ed9fb745a353a176e1222dc689de3" args="(IControl c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IControl.Copy </td>
          <td>(</td>
          <td class="paramtype">IControl&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the the specified control. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The control to be copied.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affa83a7ae3fce4f0137273a59e29ccc6"></a><!-- doxytag: member="UIProgressBar::Copy" ref="affa83a7ae3fce4f0137273a59e29ccc6" args="(SpriteRoot s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all the vital attributes of another sprite. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>Source sprite to be copied.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5565c5215ef4ca5d0fe99c1114f96d08"></a><!-- doxytag: member="UIProgressBar::Copy" ref="a5565c5215ef4ca5d0fe99c1114f96d08" args="(SpriteRoot s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void UIProgressBar.Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all the attributes of another sprite. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A reference to the sprite to be copied.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_auto_sprite_base.html#af16ce95c23cf996869c67bfbd0aa665e">AutoSpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="a714ac32248117514d8b6f7a27551ef72"></a><!-- doxytag: member="UIProgressBar::CopyAll" ref="a714ac32248117514d8b6f7a27551ef72" args="(SpriteRoot s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AutoSpriteBase.CopyAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all the attributes of another sprite, including its edit-time TextureAnimations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A reference to the sprite to be copied.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9386b761e4b3f1c5df98b7a9e5c37107"></a><!-- doxytag: member="UIProgressBar::Create" ref="a9386b761e4b3f1c5df98b7a9e5c37107" args="(string name, Vector3 pos, Quaternion rotation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_u_i_progress_bar.html">UIProgressBar</a> UIProgressBar.Create </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Quaternion&nbsp;</td>
          <td class="paramname"> <em>rotation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a GameObject and attaches this component type to it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name to give to the new GameObject.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position, in world space, where the new object should be created.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rotation</em>&nbsp;</td><td>Rotation of the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a reference to the component.</dd></dl>

</div>
</div>
<a class="anchor" id="a17015a86cbcb12e1f323cc6f0eb6047d"></a><!-- doxytag: member="UIProgressBar::Create" ref="a17015a86cbcb12e1f323cc6f0eb6047d" args="(string name, Vector3 pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_u_i_progress_bar.html">UIProgressBar</a> UIProgressBar.Create </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector3&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a GameObject and attaches this component type to it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name to give to the new GameObject.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>Position, in world space, where the new object should be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a reference to the component.</dd></dl>

</div>
</div>
<a class="anchor" id="a1f5ee0eb97ebc94d31fc1e31fcb12e68"></a><!-- doxytag: member="UIProgressBar::Delete" ref="a1f5ee0eb97ebc94d31fc1e31fcb12e68" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void SpriteBase.Delete </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If non-managed, call <a class="el" href="class_sprite_base.html#a1f5ee0eb97ebc94d31fc1e31fcb12e68" title="If non-managed, call Delete() before destroying this component or the GameObject...">Delete()</a> before destroying this component or the GameObject to which it is attached. Memory leaks can ensue otherwise. </p>

<p>Reimplemented from <a class="el" href="class_sprite_root.html#a53e588efbe27ba78648f402f9c8f6a13">SpriteRoot</a>.</p>

</div>
</div>
<a class="anchor" id="a4be4f7e5323edbe6890363afa6686638"></a><!-- doxytag: member="UIProgressBar::DoAnim" ref="a4be4f7e5323edbe6890363afa6686638" args="(UVAnimation anim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.DoAnim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_u_v_animation.html">UVAnimation</a>&nbsp;</td>
          <td class="paramname"> <em>anim</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plays the specified animation only if it is not already playing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>anim</em>&nbsp;</td><td>Reference to the animation to play.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6719f34a9728652829e1046d366c4be"></a><!-- doxytag: member="UIProgressBar::DoAnim" ref="af6719f34a9728652829e1046d366c4be" args="(string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.DoAnim </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plays the specified animation only if it is not already playing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the animation to play.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad441cd232a70b064def9e906284aba0a"></a><!-- doxytag: member="UIProgressBar::DoAnim" ref="ad441cd232a70b064def9e906284aba0a" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.DoAnim </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plays the specified animation only if it is not already playing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index of the animation to play.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f77566caf369e7e14541c763c00a565"></a><!-- doxytag: member="UIProgressBar::GetAnim" ref="a2f77566caf369e7e14541c763c00a565" args="(string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_u_v_animation.html">UVAnimation</a> AutoSpriteBase.GetAnim </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to the animation that matches the name specified. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the animation sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to the animation, if found, null otherwise.</dd></dl>

</div>
</div>
<a class="anchor" id="a729b35193db1829b0732151d4de39d05"></a><!-- doxytag: member="UIProgressBar::GetCenterPoint" ref="a729b35193db1829b0732151d4de39d05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.GetCenterPoint </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the center point of the sprite, taking into account the actual positions of vertices. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The center point of the sprite.</dd></dl>

</div>
</div>
<a class="anchor" id="ad76fb600b3e93043fa4110b9da87c73e"></a><!-- doxytag: member="UIProgressBar::GetCurAnim" ref="ad76fb600b3e93043fa4110b9da87c73e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_u_v_animation.html">UVAnimation</a> AutoSpriteBase.GetCurAnim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to the currently selected animation. NOTE: This does not mean the animation is currently playing. To determine whether the animation is playing, use <a class="el" href="class_sprite_base.html#ac98a457ace0eee0fecf82c8e089cc1a5" title="Returns whether the sprite is currently animating.">IsAnimating</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to the currently selected animation.</dd></dl>

</div>
</div>
<a class="anchor" id="afb7965badcdaa58e6e4a0cbcb0ae8f5b"></a><!-- doxytag: member="UIProgressBar::GetStateIndex" ref="afb7965badcdaa58e6e4a0cbcb0ae8f5b" args="(string stateName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override int AutoSpriteBase.GetStateIndex </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>stateName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the state with the specified name. -1 if no state matching the specified name is found. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stateName</em>&nbsp;</td><td>The name of the state sought.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The zero-based index of the state, or -1 if no state is found by that name.</dd></dl>

<p>Implements <a class="el" href="class_sprite_root.html#afdcc033b3c5c6abcb63c2f3b6dba4596">SpriteRoot</a>.</p>

</div>
</div>
<a class="anchor" id="a0e8dd93bcc6d71d85ae304d48f534691"></a><!-- doxytag: member="UIProgressBar::GetStateLabel" ref="a0e8dd93bcc6d71d85ae304d48f534691" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string AutoSpriteControlBase.GetStateLabel </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets/sets the array of strings that correspond to each control state. </p>

</div>
</div>
<a class="anchor" id="a8c337e11b78774a1cc4e2a47d3343c95"></a><!-- doxytag: member="UIProgressBar::GetUVs" ref="a8c337e11b78774a1cc4e2a47d3343c95" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Rect SpriteRoot.GetUVs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current UV coordinates of the sprite (before bleed compensation). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Rect containing the sprite's UV coordinates.</dd></dl>

</div>
</div>
<a class="anchor" id="a778d47660b7a9a6695aa77ae24862434"></a><!-- doxytag: member="UIProgressBar::GetVertices" ref="a778d47660b7a9a6695aa77ae24862434" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 [] SpriteRoot.GetVertices </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to the sprite's vertices. NOTE: You can only directly modify the sprite's vertices if it is a non-managed sprite. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the sprite's vertices.</dd></dl>

</div>
</div>
<a class="anchor" id="aede74d26180959c308452744d7bb29e9"></a><!-- doxytag: member="UIProgressBar::Hide" ref="aede74d26180959c308452744d7bb29e9" args="(bool tf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void UIProgressBar.Hide </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>tf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hides or displays the sprite by disabling/enabling the sprite's mesh renderer component, or if managed, sets the mesh size to 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tf</em>&nbsp;</td><td>When true, the sprite is hideAtStart, when false, the sprite will be displayed.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sprite_base.html#aa1bf525b3837b3456d23d9a03dda766d">SpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="ac98a457ace0eee0fecf82c8e089cc1a5"></a><!-- doxytag: member="UIProgressBar::IsAnimating" ref="ac98a457ace0eee0fecf82c8e089cc1a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpriteBase.IsAnimating </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the sprite is currently animating. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the sprite is currently animating, false otherwise.</dd></dl>

</div>
</div>
<a class="anchor" id="abc1b7cd60a2b90903fe4ea925f9c17d1"></a><!-- doxytag: member="UIProgressBar::IsHidden" ref="abc1b7cd60a2b90903fe4ea925f9c17d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpriteRoot.IsHidden </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the sprite is currently set to be hideAtStart (whether its mesh renderer component is enabled). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True when hideAtStart, false when set to be displayed.</dd></dl>

</div>
</div>
<a class="anchor" id="a88bdbcaa86cdd2e54908dae42dd79872"></a><!-- doxytag: member="UIProgressBar::PauseAnim" ref="a88bdbcaa86cdd2e54908dae42dd79872" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.PauseAnim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pauses the currently-playing animation. </p>

</div>
</div>
<a class="anchor" id="a5ff8725f90b8609efe0f4fff819bac74"></a><!-- doxytag: member="UIProgressBar::PixelCoordToUVCoord" ref="a5ff8725f90b8609efe0f4fff819bac74" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelCoordToUVCoord </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The x-coordinate to convert.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The y-coordinate to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The coordinates converted to UV coordinates.</dd></dl>

</div>
</div>
<a class="anchor" id="ae3931a73d6842ec8a98d93b718004975"></a><!-- doxytag: member="UIProgressBar::PixelCoordToUVCoord" ref="ae3931a73d6842ec8a98d93b718004975" args="(Vector2 xy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelCoordToUVCoord </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>xy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel coordinates to UV coordinates according to the currently assigned material. NOTE: This is for converting coordinates and will reverse the Y component accordingly. For converting widths and heights, use <a class="el" href="class_sprite_root.html#aa9db529bff27dfcdbb0e5e33ed0fbc2e" title="Converts pixel-space values to UV-space scalar values according to the currently...">PixelSpaceToUVSpace</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xy</em>&nbsp;</td><td>The coordinates to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The coordinates converted to UV coordinates.</dd></dl>

</div>
</div>
<a class="anchor" id="a61151a87fd06071bd680ebad9946512e"></a><!-- doxytag: member="UIProgressBar::PixelSpaceToUVSpace" ref="a61151a87fd06071bd680ebad9946512e" args="(int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelSpaceToUVSpace </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X-value to convert.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y-value to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The values converted to UV space.</dd></dl>

</div>
</div>
<a class="anchor" id="aa9db529bff27dfcdbb0e5e33ed0fbc2e"></a><!-- doxytag: member="UIProgressBar::PixelSpaceToUVSpace" ref="aa9db529bff27dfcdbb0e5e33ed0fbc2e" args="(Vector2 xy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 SpriteRoot.PixelSpaceToUVSpace </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>xy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts pixel-space values to UV-space scalar values according to the currently assigned material. NOTE: This is for converting widths and heights-not coordinates (which have reversed Y-coordinates). For coordinates, use <a class="el" href="class_sprite_root.html#ae3931a73d6842ec8a98d93b718004975" title="Converts pixel coordinates to UV coordinates according to the currently assigned...">PixelCoordToUVCoord</a>()! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xy</em>&nbsp;</td><td>The values to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The values converted to UV space.</dd></dl>

</div>
</div>
<a class="anchor" id="ad1fe80cecaf01875aa37cc2cefeee2df"></a><!-- doxytag: member="UIProgressBar::PlayAnim" ref="ad1fe80cecaf01875aa37cc2cefeee2df" args="(string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void AutoSpriteBase.PlayAnim </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the animation to play.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sprite_base.html">SpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="a3a4a62fb2cb35e1bc56a8431fd9b546b"></a><!-- doxytag: member="UIProgressBar::PlayAnim" ref="a3a4a62fb2cb35e1bc56a8431fd9b546b" args="(string name, int frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.PlayAnim </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the animation to play.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame</em>&nbsp;</td><td>The zero-based index of the frame at which to start playing.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acdaf95fd4a39f650b5e856cfaab52500"></a><!-- doxytag: member="UIProgressBar::PlayAnim" ref="acdaf95fd4a39f650b5e856cfaab52500" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void AutoSpriteBase.PlayAnim </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index of the animation to play.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sprite_base.html">SpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="ab46b9872a258096efef96864d42e8e9f"></a><!-- doxytag: member="UIProgressBar::PlayAnim" ref="ab46b9872a258096efef96864d42e8e9f" args="(int index, int frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.PlayAnim </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index of the animation to play.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame</em>&nbsp;</td><td>The zero-based index of the frame at which to start playing.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a438d2824e04660d82a77abc839ffb845"></a><!-- doxytag: member="UIProgressBar::PlayAnim" ref="a438d2824e04660d82a77abc839ffb845" args="(UVAnimation anim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.PlayAnim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_u_v_animation.html">UVAnimation</a>&nbsp;</td>
          <td class="paramname"> <em>anim</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>anim</em>&nbsp;</td><td>A reference to the animation to play.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5f3e9d674ab41aa1e069ec01517992d"></a><!-- doxytag: member="UIProgressBar::PlayAnim" ref="ac5f3e9d674ab41aa1e069ec01517992d" args="(UVAnimation anim, int frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.PlayAnim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_u_v_animation.html">UVAnimation</a>&nbsp;</td>
          <td class="paramname"> <em>anim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts playing the specified animation Note: this doesn't resume from a pause, it completely restarts the animation. To unpause, use <a class="el" href="class_auto_sprite_base.html#a82842d7d4dc6bdeb296e838221658e84" title="Resumes an animation from where it left off previously.">UnpauseAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>anim</em>&nbsp;</td><td>A reference to the animation to play.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame</em>&nbsp;</td><td>The zero-based index of the frame at which to start playing.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad384def788209def1799cb0480dd0da4"></a><!-- doxytag: member="UIProgressBar::PlayAnimInReverse" ref="ad384def788209def1799cb0480dd0da4" args="(string name, int frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.PlayAnimInReverse </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the animation to play in reverse.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame</em>&nbsp;</td><td>The zero-based index of the frame at which to start playing.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ae3268e68a5130cc67074041ca97d1c"></a><!-- doxytag: member="UIProgressBar::PlayAnimInReverse" ref="a1ae3268e68a5130cc67074041ca97d1c" args="(string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void AutoSpriteBase.PlayAnimInReverse </td>
          <td>(</td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the animation to play in reverse.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sprite_base.html">SpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="a9d701fbeeba36c4d9fe26a22f83b931a"></a><!-- doxytag: member="UIProgressBar::PlayAnimInReverse" ref="a9d701fbeeba36c4d9fe26a22f83b931a" args="(int index, int frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.PlayAnimInReverse </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index of the animation to play in reverse.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame</em>&nbsp;</td><td>The zero-based index of the frame at which to start playing.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb5971eab818510cfc5560a5a2c25073"></a><!-- doxytag: member="UIProgressBar::PlayAnimInReverse" ref="afb5971eab818510cfc5560a5a2c25073" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void AutoSpriteBase.PlayAnimInReverse </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index of the animation to play in reverse.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sprite_base.html">SpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="a7b68631bf06ebefe6f27ade8db16274d"></a><!-- doxytag: member="UIProgressBar::PlayAnimInReverse" ref="a7b68631bf06ebefe6f27ade8db16274d" args="(UVAnimation anim, int frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.PlayAnimInReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_u_v_animation.html">UVAnimation</a>&nbsp;</td>
          <td class="paramname"> <em>anim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>anim</em>&nbsp;</td><td>Reference to the animation to play in reverse.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame</em>&nbsp;</td><td>The zero-based index of the frame at which to start playing.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3f9440921b92de0bcfff9b3f873f4a9"></a><!-- doxytag: member="UIProgressBar::PlayAnimInReverse" ref="ab3f9440921b92de0bcfff9b3f873f4a9" args="(UVAnimation anim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.PlayAnimInReverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_u_v_animation.html">UVAnimation</a>&nbsp;</td>
          <td class="paramname"> <em>anim</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like PlayAnim, but plays the animation in reverse. See <a class="el" href="class_auto_sprite_base.html#ac5f3e9d674ab41aa1e069ec01517992d" title="Starts playing the specified animation Note: this doesn&#39;t resume from a pause...">PlayAnim</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>anim</em>&nbsp;</td><td>Reference to the animation to play in reverse.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aabf07745fff23716a19e591a4d00ecb0"></a><!-- doxytag: member="UIProgressBar::PositionOnScreen" ref="aabf07745fff23716a19e591a4d00ecb0" args="(Vector3 pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.PositionOnScreen </td>
          <td>(</td>
          <td class="paramtype">Vector3&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Positions the object using screen coordinates, according to the relativity settings stored in relativeToScreen. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The X and Y screen coordinates where the object should be positioned, as well as the Z coordinate which represents the distance in front of the camera.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a481a3e5c7d1b3370935564ca611fa9fe"></a><!-- doxytag: member="UIProgressBar::PositionOnScreen" ref="a481a3e5c7d1b3370935564ca611fa9fe" args="(int x, int y, float depth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.PositionOnScreen </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>depth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Positions the object using screen coordinates, according to the relativity settings stored in relativeToScreen. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The number of pixels in the X axis relative to the position specified in relativeToScreen.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The number of pixels in the Y axis relative to the position specified in relativeToScreen.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>The distance the object should be in front of the camera.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09d7f0014281fa0dcdd872c8ad4826a9"></a><!-- doxytag: member="UIProgressBar::PositionOnScreen" ref="a09d7f0014281fa0dcdd872c8ad4826a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.PositionOnScreen </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Repositions the object using the existing screen-space settings. </p>

</div>
</div>
<a class="anchor" id="a10f2bcae2161110b2acd5e5b9cca3300"></a><!-- doxytag: member="UIProgressBar::RemoveSpriteresizedDelegate" ref="a10f2bcae2161110b2acd5e5b9cca3300" args="(SpriteResizedDelegate del)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.RemoveSpriteresizedDelegate </td>
          <td>(</td>
          <td class="paramtype">SpriteResizedDelegate&nbsp;</td>
          <td class="paramname"> <em>del</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the specified delegate from the list of those to be called when the sprite is resized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>del</em>&nbsp;</td><td>The delegate to be removed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b88afbf9c807629620803fc9e0fb982"></a><!-- doxytag: member="UIProgressBar::RevertToStatic" ref="a8b88afbf9c807629620803fc9e0fb982" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.RevertToStatic </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverts the sprite to its static (non-animating) default appearance. </p>

</div>
</div>
<a class="anchor" id="af114f93fa3ad60b469e07346911a5cad"></a><!-- doxytag: member="UIProgressBar::SetAnchor" ref="af114f93fa3ad60b469e07346911a5cad" args="(ANCHOR_METHOD a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetAnchor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the anchor method to use. See <a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The anchor method to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a923fa607ba560c946de87c05e6da85c5"></a><!-- doxytag: member="UIProgressBar::SetAnimCompleteDelegate" ref="a923fa607ba560c946de87c05e6da85c5" args="(AnimCompleteDelegate del)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.SetAnimCompleteDelegate </td>
          <td>(</td>
          <td class="paramtype">AnimCompleteDelegate&nbsp;</td>
          <td class="paramname"> <em>del</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the delegate to be called upon animation completion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>del</em>&nbsp;</td><td>The delegate to be called when an animation finishes playing.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad31805dac2d46592bc30a95eabf899cb"></a><!-- doxytag: member="UIProgressBar::SetAnimFrameDelegate" ref="ad31805dac2d46592bc30a95eabf899cb" args="(AnimFrameDelegate del)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.SetAnimFrameDelegate </td>
          <td>(</td>
          <td class="paramtype">AnimFrameDelegate&nbsp;</td>
          <td class="paramname"> <em>del</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the delegate to be called each frame of animation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>del</em>&nbsp;</td><td>The delegate to be called each frame of animation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9108d36331abd7a6b629b3af7193a85"></a><!-- doxytag: member="UIProgressBar::SetBleedCompensation" ref="ab9108d36331abd7a6b629b3af7193a85" args="(Vector2 xy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetBleedCompensation </td>
          <td>(</td>
          <td class="paramtype">Vector2&nbsp;</td>
          <td class="paramname"> <em>xy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>). </p>

</div>
</div>
<a class="anchor" id="a26d2276f1705f7e61019cf621dd6d2b1"></a><!-- doxytag: member="UIProgressBar::SetBleedCompensation" ref="a26d2276f1705f7e61019cf621dd6d2b1" args="(float x, float y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetBleedCompensation </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the bleed compensation to use (see <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f" title="Will contract the UV edges of the sprite by the specified amount to prevent &quot;bleeding&quot;...">bleedCompensation</a>). </p>

</div>
</div>
<a class="anchor" id="aa22b93ae30aac03c4c13eef2b197a78c"></a><!-- doxytag: member="UIProgressBar::SetColor" ref="aa22b93ae30aac03c4c13eef2b197a78c" args="(Color c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void UIProgressBar.SetColor </td>
          <td>(</td>
          <td class="paramtype">Color&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's color to the specified color. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>Color to shade the sprite.</td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_sprite_root.html#a07898604b8c12c66429d26e8d6fbc3a9">SpriteRoot</a>.</p>

</div>
</div>
<a class="anchor" id="a58d86446fef1c870cd7eb43ce7f0d1b0"></a><!-- doxytag: member="UIProgressBar::SetCurFrame" ref="a58d86446fef1c870cd7eb43ce7f0d1b0" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.SetCurFrame </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the current frame of the current animation immediately. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Zero-based index of the desired frame.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0352fc2f67d2258329f74dcc86bd4d56"></a><!-- doxytag: member="UIProgressBar::SetDrawLayer" ref="a0352fc2f67d2258329f74dcc86bd4d56" args="(int layer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetDrawLayer </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>layer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the draw layer of the sprite (only applies to managed sprites). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>layer</em>&nbsp;</td><td>The draw layer of the sprite. Lower values cause an earlier draw order, higher values, a later draw order.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a355b24c10aa7ae976c21e944f3eb22f9"></a><!-- doxytag: member="UIProgressBar::SetFrameInfo" ref="a355b24c10aa7ae976c21e944f3eb22f9" args="(SPRITE_FRAME fInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetFrameInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_p_r_i_t_e___f_r_a_m_e.html">SPRITE_FRAME</a>&nbsp;</td>
          <td class="paramname"> <em>fInfo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's frame info, which includes UVs, offsets, etc. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fInfo</em>&nbsp;</td><td>A <a class="el" href="struct_s_p_r_i_t_e___f_r_a_m_e.html">SPRITE_FRAME</a> structure containing the frame info.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ac2df7765bc1baeb3643948024b30a1"></a><!-- doxytag: member="UIProgressBar::SetFramerate" ref="a2ac2df7765bc1baeb3643948024b30a1" args="(float fps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.SetFramerate </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>fps</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the framerate at which the current animation plays. NOTE: This only has effect if called AFTER PlayAnim() is called. Otherwise, PlayAnim() sets the framerate to whatever is specified in the animation itself. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fps</em>&nbsp;</td><td>The new framerate, in frames per second.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ae2f4d7bce23b55d8b9d273434623e7"></a><!-- doxytag: member="UIProgressBar::SetOffset" ref="a6ae2f4d7bce23b55d8b9d273434623e7" args="(Vector3 o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetOffset </td>
          <td>(</td>
          <td class="paramtype">Vector3&nbsp;</td>
          <td class="paramname"> <em>o</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the offset of the sprite from its GameObject. See <a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457" title="Offsets the sprite, in world space, from the center of its GameObject.">offset</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The offset to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adce43163ad8ad0693c3ea7c109d8408b"></a><!-- doxytag: member="UIProgressBar::SetPlane" ref="adce43163ad8ad0693c3ea7c109d8408b" args="(SPRITE_PLANE p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the plane in which the sprite is to be drawn. See: <a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The plane in which the sprite should be drawn.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf9809122c570941ff132a9904dcc93c"></a><!-- doxytag: member="UIProgressBar::SetSize" ref="adf9809122c570941ff132a9904dcc93c" args="(float width, float height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetSize </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the physical dimensions of the sprite in the plane selected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width of the sprite in world space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height of the sprite in world space.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8849952300de0c69e246cea541d30e3a"></a><!-- doxytag: member="UIProgressBar::SetSpriteResizedDelegate" ref="a8849952300de0c69e246cea541d30e3a" args="(SpriteResizedDelegate del)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteBase.SetSpriteResizedDelegate </td>
          <td>(</td>
          <td class="paramtype">SpriteResizedDelegate&nbsp;</td>
          <td class="paramname"> <em>del</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the delegate to be called when the sprite is resized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>del</em>&nbsp;</td><td>The delegate to be called when the sprite is resized.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b86d05e9616ec6d21f0c7e6d486f081"></a><!-- doxytag: member="UIProgressBar::SetState" ref="a1b86d05e9616ec6d21f0c7e6d486f081" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void AutoSpriteBase.SetState </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite to the specified state/animation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The zero-based index of the desired state/animation.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_sprite_root.html#a4df752403ae612fea2d492cfaf131e0b">SpriteRoot</a>.</p>

</div>
</div>
<a class="anchor" id="a4be330b4be1cb38e1eee340b6cc312e5"></a><!-- doxytag: member="UIProgressBar::SetStateLabel" ref="a4be330b4be1cb38e1eee340b6cc312e5" args="(int index, string label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AutoSpriteControlBase.SetStateLabel </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&nbsp;</td>
          <td class="paramname"> <em>label</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the string for the specified state label. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>index of the state to set.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>label</em>&nbsp;</td><td>The string to set as the state's label.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac975a3763bd5f83a38c5934a5f2d7ab2"></a><!-- doxytag: member="UIProgressBar::Setup" ref="ac975a3763bd5f83a38c5934a5f2d7ab2" args="(float w, float h, Material material)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.Setup </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Material&nbsp;</td>
          <td class="paramname"> <em>material</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets up the essential elements of a sprite. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>The width, in local space, of the sprite.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The height, in local space, of the sprite.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>material</em>&nbsp;</td><td>The material to use for the sprite.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42253e9abd7dd0b294c6e4bbc8acd3d7"></a><!-- doxytag: member="UIProgressBar::Setup" ref="a42253e9abd7dd0b294c6e4bbc8acd3d7" args="(float w, float h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.Setup </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets up the essential elements of a sprite. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>w</em>&nbsp;</td><td>The width, in local space, of the sprite.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>The height, in local space, of the sprite.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7b38c49c508eb9300fa9116a3074ace"></a><!-- doxytag: member="UIProgressBar::SetUVs" ref="ab7b38c49c508eb9300fa9116a3074ace" args="(Rect uv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetUVs </td>
          <td>(</td>
          <td class="paramtype">Rect&nbsp;</td>
          <td class="paramname"> <em>uv</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's UVs to the specified values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nextFrame</em>&nbsp;</td><td>A Rect containing the new UV coordinates.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2099af0859ccd329e09ff83177811127"></a><!-- doxytag: member="UIProgressBar::SetUVsFromPixelCoords" ref="a2099af0859ccd329e09ff83177811127" args="(Rect pxCoords)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetUVsFromPixelCoords </td>
          <td>(</td>
          <td class="paramtype">Rect&nbsp;</td>
          <td class="paramname"> <em>pxCoords</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite's UVs from pixel coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pxCoords</em>&nbsp;</td><td>A rect containing the pixel coordinates.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c7f3a0e628f66c612bc80ff4a003021"></a><!-- doxytag: member="UIProgressBar::SetWindingOrder" ref="a4c7f3a0e628f66c612bc80ff4a003021" args="(WINDING_ORDER order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SpriteRoot.SetWindingOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>&nbsp;</td>
          <td class="paramname"> <em>order</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the winding order to use. See <a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>The winding order to use.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a225681fbdb6d79c769c107293949f37f"></a><!-- doxytag: member="UIProgressBar::SpriteResizedDelegate" ref="a225681fbdb6d79c769c107293949f37f" args="(float newWidth, float newHeight, SpriteRoot sprite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delegate void SpriteRoot.SpriteResizedDelegate </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>newWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>newHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sprite_root.html">SpriteRoot</a>&nbsp;</td>
          <td class="paramname"> <em>sprite</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines a delegate that can be called upon resizing of the sprite. Use this if you want to adjust colliders, etc, when the sprites dimensions are resized. </p>

</div>
</div>
<a class="anchor" id="ad169d4a6bc4aaa2d90bf99b0fc887f23"></a><!-- doxytag: member="UIProgressBar::StopAnim" ref="ad169d4a6bc4aaa2d90bf99b0fc887f23" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void AutoSpriteBase.StopAnim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops the current animation from playing and resets it to the beginning for playing again. The sprite then reverts to the static image. </p>

<p>Reimplemented from <a class="el" href="class_sprite_base.html#aa3d61d10c3119a19ed83376e2269d121">SpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="a9d9a88cd142782d55a77c8dc0b8bc77b"></a><!-- doxytag: member="UIProgressBar::Unclip" ref="a9d9a88cd142782d55a77c8dc0b8bc77b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override void UIProgressBar.Unclip </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes any clipping that is being applied to the sprite. </p>

<p>Reimplemented from <a class="el" href="class_sprite_root.html#a97d10b8e450bb429bab82eaeda1bdf12">SpriteRoot</a>.</p>

</div>
</div>
<a class="anchor" id="a82842d7d4dc6bdeb296e838221658e84"></a><!-- doxytag: member="UIProgressBar::UnpauseAnim" ref="a82842d7d4dc6bdeb296e838221658e84" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoSpriteBase.UnpauseAnim </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resumes an animation from where it left off previously. </p>

</div>
</div>
<a class="anchor" id="a0fb97744935800a9d471d38d2520e855"></a><!-- doxytag: member="UIProgressBar::UpdateCollider" ref="a0fb97744935800a9d471d38d2520e855" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AutoSpriteControlBase.UpdateCollider </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the collider of the control so that it encompasses the extents of the control's content. NOTE: To include the control's associated text in the calculation, be sure to check the includeTextInAutoCollider box. </p>

</div>
</div>
<a class="anchor" id="aff78916688134aa447c8071fe552b209"></a><!-- doxytag: member="UIProgressBar::UpdateUVs" ref="aff78916688134aa447c8071fe552b209" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SpriteRoot.UpdateUVs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies any changes to the UVs to the actual sprite mesh. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a3ea8ab87a750bfafc3cffc34b14f3eba"></a><!-- doxytag: member="UIProgressBar::anchor" ref="a3ea8ab87a750bfafc3cffc34b14f3eba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a> <a class="el" href="class_sprite_root.html#a3ea8ab87a750bfafc3cffc34b14f3eba">SpriteRoot.anchor</a> = ANCHOR_METHOD.TEXTURE_OFFSET<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Anchor method to use. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_sprite_root.html#a79b7138073d866284a170e4d8b3a9217">ANCHOR_METHOD</a></dd></dl>
<p>. </p>

</div>
</div>
<a class="anchor" id="a2a66708e5326f2385b68dad5f7a47afa"></a><!-- doxytag: member="UIProgressBar::animations" ref="a2a66708e5326f2385b68dad5f7a47afa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_u_v_animation.html">UVAnimation</a> [] <a class="el" href="class_auto_sprite_base.html#a2a66708e5326f2385b68dad5f7a47afa">AutoSpriteBase.animations</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Holds the actual UV sequences that will be used at run-time. </p>

</div>
</div>
<a class="anchor" id="ad6bda2f46906d69166ee4b931c3108dd"></a><!-- doxytag: member="UIProgressBar::autoResize" ref="ad6bda2f46906d69166ee4b931c3108dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd">SpriteRoot.autoResize</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically resizes the sprite based on its new UV dimensions compared to its previous dimensions. Setting this to true allows you to use non-uniform sized sprites for animation without causing the sprite to appear "squashed" while animating. </p>

</div>
</div>
<a class="anchor" id="a8a9de6bf34778b74f87b3d8e71c3342f"></a><!-- doxytag: member="UIProgressBar::bleedCompensation" ref="a8a9de6bf34778b74f87b3d8e71c3342f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 <a class="el" href="class_sprite_root.html#a8a9de6bf34778b74f87b3d8e71c3342f">SpriteRoot.bleedCompensation</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Will contract the UV edges of the sprite by the specified amount to prevent "bleeding" from neighboring pixels, especially when mipmapping. </p>

</div>
</div>
<a class="anchor" id="a206a1db950fc52aaef5b535a7b1a938a"></a><!-- doxytag: member="UIProgressBar::color" ref="a206a1db950fc52aaef5b535a7b1a938a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Color <a class="el" href="class_sprite_root.html#a206a1db950fc52aaef5b535a7b1a938a">SpriteRoot.color</a> = Color.white<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The color to be used by all four of the sprite's vertices. This can be used to color, highlight, or fade the sprite. Be sure to use a vertex-colored shader for this to have an effect. </p>

</div>
</div>
<a class="anchor" id="a5daea5d98746bfeddc7c0d2a26314fd2"></a><!-- doxytag: member="UIProgressBar::data" ref="a5daea5d98746bfeddc7c0d2a26314fd2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">object AutoSpriteControlBase.data<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Can hold a reference to any data that the developer wishes to be associated with the control. </p>

</div>
</div>
<a class="anchor" id="a9d3a230326feff1dc46a065f50d4d5e8"></a><!-- doxytag: member="UIProgressBar::defaultAnim" ref="a9d3a230326feff1dc46a065f50d4d5e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_sprite_base.html#a9d3a230326feff1dc46a065f50d4d5e8">SpriteBase.defaultAnim</a> = 0<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Index of the animation to play by default. </p>

</div>
</div>
<a class="anchor" id="a35b772db0c95797e01440199546a375b"></a><!-- doxytag: member="UIProgressBar::DittoString" ref="a35b772db0c95797e01440199546a375b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string AutoSpriteControlBase.DittoString = &quot;[\&quot;]&quot;<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>String whose meaning is to keep the previous state's label. </p>

</div>
</div>
<a class="anchor" id="a38effd07c9700447283d092a0981e411"></a><!-- doxytag: member="UIProgressBar::drawLayer" ref="a38effd07c9700447283d092a0981e411" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_sprite_root.html#a38effd07c9700447283d092a0981e411">SpriteRoot.drawLayer</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The layer in which the sprite will be drawn if managed. </p>

</div>
</div>
<a class="anchor" id="aeb04f02675c7f90ecd576151e6f3e002"></a><!-- doxytag: member="UIProgressBar::filledLayers" ref="aeb04f02675c7f90ecd576151e6f3e002" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html">SpriteRoot</a> [] <a class="el" href="class_u_i_progress_bar.html#aeb04f02675c7f90ecd576151e6f3e002">UIProgressBar.filledLayers</a> = new <a class="el" href="class_sprite_root.html">SpriteRoot</a>[0]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An array of references to sprites which will visually represent this control. Each element (layer) represents another layer to be drawn. This allows you to use multiple sprites to draw a single control, achieving a sort of layered effect. Ex: You can use a second layer to overlay a button with a highlight effect. </p>

</div>
</div>
<a class="anchor" id="a6bf98fa584df909a7864c4bccfda0b75"></a><!-- doxytag: member="UIProgressBar::height" ref="a6bf98fa584df909a7864c4bccfda0b75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_sprite_root.html#a6bf98fa584df909a7864c4bccfda0b75">SpriteRoot.height</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Height of the sprite in world space. </p>

</div>
</div>
<a class="anchor" id="a9905374808829c2c6a15ffeb0170bf52"></a><!-- doxytag: member="UIProgressBar::hideAtStart" ref="a9905374808829c2c6a15ffeb0170bf52" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#a9905374808829c2c6a15ffeb0170bf52">SpriteRoot.hideAtStart</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether the sprite will be hideAtStart when it starts. </p>

</div>
</div>
<a class="anchor" id="a202cda8687f106341921b2268955dbd4"></a><!-- doxytag: member="UIProgressBar::includeTextInAutoCollider" ref="a202cda8687f106341921b2268955dbd4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoSpriteControlBase.includeTextInAutoCollider<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When true, of a collider is generated for the control, the associated text is taken into account when calculating the extents of the collider. </p>

</div>
</div>
<a class="anchor" id="a27b40cf9515a2d0cae6391fc974c8316"></a><!-- doxytag: member="UIProgressBar::managed" ref="a27b40cf9515a2d0cae6391fc974c8316" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#a27b40cf9515a2d0cae6391fc974c8316">SpriteRoot.managed</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When true, the sprite will be managed by the selected sprite manager script. When false, the sprite has its own mesh and will be batched automatically with other sprites (when available - Unity iPhone). </p>

</div>
</div>
<a class="anchor" id="a2ce487455dd3b14e10cfa97a37b3da20"></a><!-- doxytag: member="UIProgressBar::manager" ref="a2ce487455dd3b14e10cfa97a37b3da20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_manager.html">SpriteManager</a> <a class="el" href="class_sprite_root.html#a2ce487455dd3b14e10cfa97a37b3da20">SpriteRoot.manager</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reference to the manager which will manage this sprite, provided managed is set to true. </p>

</div>
</div>
<a class="anchor" id="a437424afa712a3ae537768cc0e3a2457"></a><!-- doxytag: member="UIProgressBar::offset" ref="a437424afa712a3ae537768cc0e3a2457" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 <a class="el" href="class_sprite_root.html#a437424afa712a3ae537768cc0e3a2457">SpriteRoot.offset</a> = new Vector3()<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Offsets the sprite, in world space, from the center of its GameObject. </p>

</div>
</div>
<a class="anchor" id="a5be17e1b254ce8a2c0b2f16a0be9a3a3"></a><!-- doxytag: member="UIProgressBar::persistent" ref="a5be17e1b254ce8a2c0b2f16a0be9a3a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#a5be17e1b254ce8a2c0b2f16a0be9a3a3">SpriteRoot.persistent</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This must be set to true at design time for the sprite to survive loading a new level. </p>

</div>
</div>
<a class="anchor" id="ae3ebdc6d208c66fcc58fe9bdd1e993fe"></a><!-- doxytag: member="UIProgressBar::pixelPerfect" ref="ae3ebdc6d208c66fcc58fe9bdd1e993fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_root.html#ae3ebdc6d208c66fcc58fe9bdd1e993fe">SpriteRoot.pixelPerfect</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Automatically sizes the sprite so that it will display pixel-perfect on-screen. NOTE: If you change the orthographic size of the camera or the distance between the sprite and a perspective camera, call <a class="el" href="class_sprite_root.html#a4f2fdef32da501a717c69eef466d2135" title="Sets the camera to use when calculating a pixel-perfect sprite size.">SetCamera()</a> to make the text pixel-perfect again. However, if you want automatic resizing functionality without being pixel-perfect and therefore allowing zooming in and out, use <a class="el" href="class_sprite_root.html#ad6bda2f46906d69166ee4b931c3108dd" title="Automatically resizes the sprite based on its new UV dimensions compared to its previous...">autoResize</a> instead. </p>

</div>
</div>
<a class="anchor" id="a821509586d7b454250d1c7c0b3dd4f74"></a><!-- doxytag: member="UIProgressBar::plane" ref="a821509586d7b454250d1c7c0b3dd4f74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html#a4f354b80a58bab8f31f7966750800e57">SPRITE_PLANE</a> <a class="el" href="class_sprite_root.html#a821509586d7b454250d1c7c0b3dd4f74">SpriteRoot.plane</a> = SPRITE_PLANE.XY<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The plane in which the sprite will be drawn. </p>

</div>
</div>
<a class="anchor" id="a9c2a037051bc8954928bc97f78c8748b"></a><!-- doxytag: member="UIProgressBar::playAnimOnStart" ref="a9c2a037051bc8954928bc97f78c8748b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sprite_base.html#a9c2a037051bc8954928bc97f78c8748b">SpriteBase.playAnimOnStart</a> = false<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When set to true, the sprite will play the default animation (see <a class="el" href="class_sprite_base.html#a9d3a230326feff1dc46a065f50d4d5e8" title="Index of the animation to play by default.">defaultAnim</a>) when the sprite is instantiated. </p>

</div>
</div>
<a class="anchor" id="ad22bb073415f6850ded5d0cf3079f4a4"></a><!-- doxytag: member="UIProgressBar::spriteText" ref="ad22bb073415f6850ded5d0cf3079f4a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_text.html">SpriteText</a> AutoSpriteControlBase.spriteText<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reference to optional <a class="el" href="class_sprite_text.html">SpriteText</a> which will display this item's text. It is STRONGLY recommended that this mesh exist on a GameObject that is a child of the list item itself. </p>

</div>
</div>
<a class="anchor" id="a83e8c577eb5b24421c3d9624c7047d8e"></a><!-- doxytag: member="UIProgressBar::text" ref="a83e8c577eb5b24421c3d9624c7047d8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string AutoSpriteControlBase.text<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Text to be displayed on the control. Do not set this directly in-code. Instead, use the "Text" property or else your changes will not take effect. </p>

</div>
</div>
<a class="anchor" id="adfc2cf4856ccd7162604aa52f4c5e3fd"></a><!-- doxytag: member="UIProgressBar::textOffsetZ" ref="adfc2cf4856ccd7162604aa52f4c5e3fd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float AutoSpriteControlBase.textOffsetZ = -0.1f<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When text is generated by the control at runtime, it will, by default, have its offsetZ setting set to this value. NOTE: Negative values will result in text being in front of the control. Positive values will place the text behind the control. </p>

</div>
</div>
<a class="anchor" id="afeafcd5c4d1b332e1ff9260eee857145"></a><!-- doxytag: member="UIProgressBar::width" ref="afeafcd5c4d1b332e1ff9260eee857145" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_sprite_root.html#afeafcd5c4d1b332e1ff9260eee857145">SpriteRoot.width</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Width of the sprite in world space. </p>

</div>
</div>
<a class="anchor" id="a2053a628b672c6b3140ebc2e92264b09"></a><!-- doxytag: member="UIProgressBar::winding" ref="a2053a628b672c6b3140ebc2e92264b09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite_root.html#aa6a06ad89a880accb25794e862733074">WINDING_ORDER</a> <a class="el" href="class_sprite_root.html#a2053a628b672c6b3140ebc2e92264b09">SpriteRoot.winding</a> = WINDING_ORDER.CW<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The winding order of the sprite's polygons - determines the direction the sprite will "face". </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="ae427641cebb3e76e7a2cb2ffdf445836"></a><!-- doxytag: member="UIProgressBar::Animating" ref="ae427641cebb3e76e7a2cb2ffdf445836" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpriteBase.Animating<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Property useful for use with EZ Game Saver. When it gets set, the current animation is started. Include this, along with CurAnimIndex, as a saved property so that any playing animation is resumed. </p>

</div>
</div>
<a class="anchor" id="ab801616440fd6b9500f05dd3565d16b8"></a><!-- doxytag: member="UIProgressBar::BottomRight" ref="ab801616440fd6b9500f05dd3565d16b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.BottomRight<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the position of the bottom-right vertex of the sprite after any clipping or trimming. </p>

</div>
</div>
<a class="anchor" id="a9d4b97c1b26ca5a4c89fe9e07192a84d"></a><!-- doxytag: member="UIProgressBar::BottomRightEdge" ref="a9d4b97c1b26ca5a4c89fe9e07192a84d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 AutoSpriteControlBase.BottomRightEdge<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The bottom-right edge of the control, when no clipping or trimming is applied, and includes all layers and text. </p>

</div>
</div>
<a class="anchor" id="a07882c6777cea2dd8561c29bdccbbf47"></a><!-- doxytag: member="UIProgressBar::Clipped" ref="a07882c6777cea2dd8561c29bdccbbf47" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override bool UIProgressBar.Clipped<code> [get, set]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for whether the sprite is to be clipped by any already-specified clipping rect. </p>

<p>Reimplemented from <a class="el" href="class_sprite_root.html#a222c8253fa3ef1911732d0de73cefb49">SpriteRoot</a>.</p>

</div>
</div>
<a class="anchor" id="a651029ce108c52b8ff5c01a26bbfdfdd"></a><!-- doxytag: member="UIProgressBar::ClippingRect" ref="a651029ce108c52b8ff5c01a26bbfdfdd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override <a class="el" href="struct_rect3_d.html">Rect3D</a> UIProgressBar.ClippingRect<code> [get, set]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The rect against which the sprite should be clipped. The sprite will be immediately clipped by this rect when set. When setting, the rect should be in world space. </p>

<p>Reimplemented from <a class="el" href="class_sprite_root.html#a214c7409b2047bd2d533872271a4dc46">SpriteRoot</a>.</p>

</div>
</div>
<a class="anchor" id="a633c03fb5361d8a2a632f1ead061ebbc"></a><!-- doxytag: member="UIProgressBar::controlIsEnabled" ref="a633c03fb5361d8a2a632f1ead061ebbc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AutoSpriteControlBase.controlIsEnabled<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows you to get/set whether the control is disabled. If it is disabled, it will not receive input. </p>

</div>
</div>
<a class="anchor" id="a88bfefa27afedef3c2ab1883fdb2a364"></a><!-- doxytag: member="UIProgressBar::CurAnimIndex" ref="a88bfefa27afedef3c2ab1883fdb2a364" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SpriteBase.CurAnimIndex<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Property useful for use with EZ Game Saver. Include this as a saved property, along with Animating, so that any playing animation is resumed. </p>

</div>
</div>
<a class="anchor" id="ab38a2f9f8457e89b4aa1e1a29fc35d8d"></a><!-- doxytag: member="UIProgressBar::Data" ref="ab38a2f9f8457e89b4aa1e1a29fc35d8d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">object AutoSpriteControlBase.Data<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the data member to comply with the IControl interface. </p>

</div>
</div>
<a class="anchor" id="aacea1f4b75640daba8dcd448d2634122"></a><!-- doxytag: member="UIProgressBar::DefaultFrame" ref="aacea1f4b75640daba8dcd448d2634122" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_c_sprite_frame.html">CSpriteFrame</a> AutoSpriteBase.DefaultFrame<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the default frame of the sprite object. This is the appearance the sprite is to have in the editor. </p>

<p>Reimplemented in <a class="el" href="class_u_i_radio_btn.html#aaa765003f12874223b047de297f394ba">UIRadioBtn</a>, and <a class="el" href="class_u_i_state_toggle_btn.html#a925e858bef757dc0f6b0f2d2e67e53a7">UIStateToggleBtn</a>.</p>

</div>
</div>
<a class="anchor" id="ac5a83817fe0a7ccf7910331b2e4eb6aa"></a><!-- doxytag: member="UIProgressBar::Managed" ref="ac5a83817fe0a7ccf7910331b2e4eb6aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SpriteRoot.Managed<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the sprite to a managed or batched state. </p>

</div>
</div>
<a class="anchor" id="a9dd6488baab44307e2a674c2f2d68089"></a><!-- doxytag: member="UIProgressBar::States" ref="a9dd6488baab44307e2a674c2f2d68089" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override <a class="el" href="class_texture_anim.html">TextureAnim</a> [] UIProgressBar.States<code> [get, set]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the sprite's various states as defined in the editor (not used at runtime). </p>

<p>Reimplemented from <a class="el" href="class_auto_sprite_base.html#a9b12f9bcf2598191cf33b7a5b34ba886">AutoSpriteBase</a>.</p>

</div>
</div>
<a class="anchor" id="a77cfaeeba1f4bd9a432c79143ee49d39"></a><!-- doxytag: member="UIProgressBar::Text" ref="a77cfaeeba1f4bd9a432c79143ee49d39" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string AutoSpriteControlBase.Text<code> [get, set, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the text to be displayed in this control. </p>

</div>
</div>
<a class="anchor" id="a120de0df612b60e3722b3ef8a759faa5"></a><!-- doxytag: member="UIProgressBar::TopLeft" ref="a120de0df612b60e3722b3ef8a759faa5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.TopLeft<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the position of the top-left vertex of the sprite after any clipping or trimming. </p>

</div>
</div>
<a class="anchor" id="a4336876830973caa05ff90ddb8c2764c"></a><!-- doxytag: member="UIProgressBar::TopLeftEdge" ref="a4336876830973caa05ff90ddb8c2764c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 AutoSpriteControlBase.TopLeftEdge<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The top-left edge of the control, when no clipping or trimming is applied, and includes all layers and text. </p>

</div>
</div>
<a class="anchor" id="af4326379f44bf2e7f8410fb71add0476"></a><!-- doxytag: member="UIProgressBar::UnclippedBottomRight" ref="af4326379f44bf2e7f8410fb71add0476" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.UnclippedBottomRight<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The bottom-right corner of the sprite when no clipping or trimming is applied. </p>

</div>
</div>
<a class="anchor" id="a50292aa01cd979d345893d6a81c6f39b"></a><!-- doxytag: member="UIProgressBar::UnclippedTopLeft" ref="a50292aa01cd979d345893d6a81c6f39b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector3 SpriteRoot.UnclippedTopLeft<code> [get, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The top-left corner of the sprite when no clipping or trimming is applied. </p>

</div>
</div>
<a class="anchor" id="a7902274c1259bc2440a8d41865760d3f"></a><!-- doxytag: member="UIProgressBar::Value" ref="a7902274c1259bc2440a8d41865760d3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float UIProgressBar.Value<code> [get, set]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Represents the percent of progress. Valid range is from 0-1. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>UIProgressBar.cs</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Feb 1 18:27:11 2011 for EZ GUI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
